<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>
  Class: Encoding::Converter
  
    &mdash; Documentation by YARD 0.8.7.4
  
</title>

  <link rel="stylesheet" href="../css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="../css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '../';
  framesUrl = "../frames.html#!Encoding/Converter.html";
</script>


  <script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="../_index.html">Index (C)</a> &raquo;
    <span class='title'><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></span>
     &raquo; 
    <span class="title">Converter</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="../class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="../method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="../file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><h1>Class: Encoding::Converter
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName"><span class='object_link'><a href="../Data.html" title="Data (class)">Data</a></span></span>
      
        <ul class="fullTree">
          <li><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></li>
          
            <li class="next"><span class='object_link'><a href="../Data.html" title="Data (class)">Data</a></span></li>
          
            <li class="next">Encoding::Converter</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">transcode.c</dd>
  
</dl>
<div class="clear"></div>


  <h2>Constant Summary</h2>
  
    <dl class="constants">
      
        <dt id="INVALID_MASK-constant" class="">INVALID_MASK =
          
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ECONV_INVALID_MASK</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="INVALID_REPLACE-constant" class="">INVALID_REPLACE =
          
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ECONV_INVALID_REPLACE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="UNDEF_MASK-constant" class="">UNDEF_MASK =
          
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ECONV_UNDEF_MASK</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="UNDEF_REPLACE-constant" class="">UNDEF_REPLACE =
          
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ECONV_UNDEF_REPLACE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="UNDEF_HEX_CHARREF-constant" class="">UNDEF_HEX_CHARREF =
          
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ECONV_UNDEF_HEX_CHARREF</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="PARTIAL_INPUT-constant" class="">PARTIAL_INPUT =
          
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ECONV_PARTIAL_INPUT</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="AFTER_OUTPUT-constant" class="">AFTER_OUTPUT =
          
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ECONV_AFTER_OUTPUT</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="UNIVERSAL_NEWLINE_DECORATOR-constant" class="">UNIVERSAL_NEWLINE_DECORATOR =
          
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ECONV_UNIVERSAL_NEWLINE_DECORATOR</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="CRLF_NEWLINE_DECORATOR-constant" class="">CRLF_NEWLINE_DECORATOR =
          
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ECONV_CRLF_NEWLINE_DECORATOR</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="CR_NEWLINE_DECORATOR-constant" class="">CR_NEWLINE_DECORATOR =
          
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ECONV_CR_NEWLINE_DECORATOR</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="XML_TEXT_DECORATOR-constant" class="">XML_TEXT_DECORATOR =
          
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ECONV_XML_TEXT_DECORATOR</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="XML_ATTR_CONTENT_DECORATOR-constant" class="">XML_ATTR_CONTENT_DECORATOR =
          
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ECONV_XML_ATTR_CONTENT_DECORATOR</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="XML_ATTR_QUOTE_DECORATOR-constant" class="">XML_ATTR_QUOTE_DECORATOR =
          
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ECONV_XML_ATTR_QUOTE_DECORATOR</span><span class='rparen'>)</span></pre></dd>
      
    </dl>
  







  
    <h2>
      Class Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#asciicompat_encoding-class_method" title="asciicompat_encoding (class method)">+ (Object) <strong>asciicompat_encoding</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns the corresponding ASCII compatible encoding.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#search_convpath-class_method" title="search_convpath (class method)">+ (Object) <strong>search_convpath</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns a conversion path.</p>
</div></span>
  
</li>

      
    </ul>
  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%3D-instance_method" title="#== (instance method)">- (Boolean) <strong>==</strong>(other) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#convert-instance_method" title="#convert (instance method)">- (Object) <strong>convert</strong>(source_string) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Convert source_string and return destination_string.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#convpath-instance_method" title="#convpath (instance method)">- (Object) <strong>convpath</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns the conversion path of ec.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#destination_encoding-instance_method" title="#destination_encoding (instance method)">- (Encoding) <strong>destination_encoding</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns the destination encoding as an Encoding object.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#finish-instance_method" title="#finish (instance method)">- (String) <strong>finish</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Finishes the converter.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize-instance_method" title="#initialize (instance method)">- (Object) <strong>initialize</strong> </a>
    

    
  </span>
  
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>possible options elements:   hash form:     :invalid =&gt; nil            #
raise error on invalid byte sequence (default)     :invalid =&gt; :replace 
# replace invalid byte sequence     :undef =&gt; nil              # raise
error on undefined conversion (default)     :undef =&gt; :replace         #
replace undefined conversion     :replace =&gt; string         #
replacement string (“?” or “uFFFD” if not specified)     :newline =&gt;
:universal     # decorator for converting CRLF and CR to LF     :newline
=&gt; :crlf          # decorator for converting LF to CRLF     :newline
=&gt; :cr            # decorator for converting LF to CR    
:universal_newline =&gt; true # decorator for converting CRLF and CR to LF 
:crlf_newline =&gt; true      # decorator for converting LF to CRLF    
:cr_newline =&gt; true        # decorator for converting LF to CR     :xml
=&gt; :text              # escape as XML CharData.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#insert_output-instance_method" title="#insert_output (instance method)">- (nil) <strong>insert_output</strong>(string) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Inserts string into the encoding converter.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#inspect-instance_method" title="#inspect (instance method)">- (String) <strong>inspect</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns a printable version of ec.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#last_error-instance_method" title="#last_error (instance method)">- (Exception<sup>?</sup>) <strong>last_error</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns an exception object for the last conversion.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#primitive_convert-instance_method" title="#primitive_convert (instance method)">- (Object) <strong>primitive_convert</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>possible opt elements:   hash form:     :partial_input =&gt; true          
# source buffer may be part of larger source     :after_output =&gt; true  
# stop conversion after output before input   integer form:    
Encoding::Converter::PARTIAL_INPUT     Encoding::Converter::AFTER_OUTPUT.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#primitive_errinfo-instance_method" title="#primitive_errinfo (instance method)">- (Array) <strong>primitive_errinfo</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>primitive_errinfo returns important information regarding the last error as
a 5-element array:.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#putback-instance_method" title="#putback (instance method)">- (Object) <strong>putback</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>call-seq   ec.putback                    -&gt; string  
ec.putback(max_numbytes)      -&gt; string.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#replacement-instance_method" title="#replacement (instance method)">- (String) <strong>replacement</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns the replacement string.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#replacement%3D-instance_method" title="#replacement= (instance method)">- (Object) <strong>replacement=</strong>(string) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Sets the replacement string.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#source_encoding-instance_method" title="#source_encoding (instance method)">- (Encoding) <strong>source_encoding</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns the source encoding as an Encoding object.</p>
</div></span>
  
</li>

      
    </ul>
  


  
  
  
  
  
  <div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <h3 class="signature first" id="initialize-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>Encoding::Converter.new</strong>(source_encoding, destination_encoding) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>Encoding::Converter.new</strong>(source_encoding, destination_encoding, opt) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>Encoding::Converter.new</strong>(convpath) </span>
    
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>possible options elements:</p>

<pre class="ruby"><span class="ruby-identifier">hash</span> <span class="ruby-identifier">form</span><span class="ruby-operator">:</span>
  :<span class="ruby-identifier">invalid</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">nil</span>            <span class="ruby-comment"># raise error on invalid byte sequence (default)</span>
  :<span class="ruby-identifier">invalid</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">replace</span>       <span class="ruby-comment"># replace invalid byte sequence</span>
  :<span class="ruby-keyword">undef</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">nil</span>              <span class="ruby-comment"># raise error on undefined conversion (default)</span>
  :<span class="ruby-keyword">undef</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">replace</span>         <span class="ruby-comment"># replace undefined conversion</span>
  :<span class="ruby-identifier">replace</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">string</span>         <span class="ruby-comment"># replacement string (&quot;?&quot; or &quot;\uFFFD&quot; if not specified)</span>
  :<span class="ruby-identifier">newline</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">universal</span>     <span class="ruby-comment"># decorator for converting CRLF and CR to LF</span>
  :<span class="ruby-identifier">newline</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">crlf</span>          <span class="ruby-comment"># decorator for converting LF to CRLF</span>
  :<span class="ruby-identifier">newline</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">cr</span>            <span class="ruby-comment"># decorator for converting LF to CR</span>
  :<span class="ruby-identifier">universal_newline</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span> <span class="ruby-comment"># decorator for converting CRLF and CR to LF</span>
  :<span class="ruby-identifier">crlf_newline</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>      <span class="ruby-comment"># decorator for converting LF to CRLF</span>
  :<span class="ruby-identifier">cr_newline</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>        <span class="ruby-comment"># decorator for converting LF to CR</span>
  :<span class="ruby-identifier">xml</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">text</span>              <span class="ruby-comment"># escape as XML CharData.</span>
  :<span class="ruby-identifier">xml</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">attr</span>              <span class="ruby-comment"># escape as XML AttValue</span>
<span class="ruby-identifier">integer</span> <span class="ruby-identifier">form</span><span class="ruby-operator">:</span>
  <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span><span class="ruby-operator">::</span><span class="ruby-constant">INVALID_REPLACE</span>
  <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span><span class="ruby-operator">::</span><span class="ruby-constant">UNDEF_REPLACE</span>
  <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span><span class="ruby-operator">::</span><span class="ruby-constant">UNDEF_HEX_CHARREF</span>
  <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span><span class="ruby-operator">::</span><span class="ruby-constant">UNIVERSAL_NEWLINE_DECORATOR</span>
  <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span><span class="ruby-operator">::</span><span class="ruby-constant">CRLF_NEWLINE_DECORATOR</span>
  <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span><span class="ruby-operator">::</span><span class="ruby-constant">CR_NEWLINE_DECORATOR</span>
  <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span><span class="ruby-operator">::</span><span class="ruby-constant">XML_TEXT_DECORATOR</span>
  <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span><span class="ruby-operator">::</span><span class="ruby-constant">XML_ATTR_CONTENT_DECORATOR</span>
  <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span><span class="ruby-operator">::</span><span class="ruby-constant">XML_ATTR_QUOTE_DECORATOR</span>
</pre>

<p>Encoding::Converter.new creates an instance of Encoding::Converter.</p>

<p>Source_encoding and destination_encoding should be a string or Encoding
object.</p>

<p>opt should be nil, a hash or an integer.</p>

<p>convpath should be an array. convpath may contain</p>
<ul><li>
<p>two-element arrays which contain encodings or encoding names, or</p>
</li><li>
<p>strings representing decorator names.</p>
</li></ul>

<p>Encoding::Converter.new optionally takes an option. The option should be a
hash or an integer. The option hash can contain :invalid =&gt; nil, etc.
The option integer should be logical-or of constants such as
Encoding::Converter::INVALID_REPLACE, etc.</p>
<dl class="rdoc-list label-list"><dt>:invalid =&gt; nil
<dd>
<p>Raise error on invalid byte sequence.  This is a default behavior.</p>
</dd><dt>:invalid =&gt; :replace
<dd>
<p>Replace invalid byte sequence by replacement string.</p>
</dd><dt>:undef =&gt; nil
<dd>
<p>Raise an error if a character in source_encoding is not defined in
destination_encoding. This is a default behavior.</p>
</dd><dt>:undef =&gt; :replace
<dd>
<p>Replace undefined character in destination_encoding with replacement
string.</p>
</dd><dt>:replace =&gt; string
<dd>
<p>Specify the replacement string. If not specified, “uFFFD” is used for
Unicode encodings and “?” for others.</p>
</dd><dt>:universal_newline =&gt; true
<dd>
<p>Convert CRLF and CR to LF.</p>
</dd><dt>:crlf_newline =&gt; true
<dd>
<p>Convert LF to CRLF.</p>
</dd><dt>:cr_newline =&gt; true
<dd>
<p>Convert LF to CR.</p>
</dd><dt>:xml =&gt; :text
<dd>
<p>Escape as XML CharData. This form can be used as a HTML 4.0 #PCDATA.</p>
<ul><li>
<p>‘&amp;’ -&gt; ‘&amp;amp;’</p>
</li><li>
<p>‘&lt;’ -&gt; ‘&amp;lt;’</p>
</li><li>
<p>‘&gt;’ -&gt; ‘&amp;gt;’</p>
</li><li>
<p>undefined characters in destination_encoding -&gt; hexadecimal CharRef such
as &amp;#xHH;</p>
</li></ul>
</dd><dt>:xml =&gt; :attr
<dd>
<p>Escape as XML AttValue. The converted result is quoted as “…”. This form
can be used as a HTML 4.0 attribute value.</p>
<ul><li>
<p>‘&amp;’ -&gt; ‘&amp;amp;’</p>
</li><li>
<p>‘&lt;’ -&gt; ‘&amp;lt;’</p>
</li><li>
<p>‘&gt;’ -&gt; ‘&amp;gt;’</p>
</li><li>
<p>‘“’ -&gt; ‘&amp;quot;’</p>
</li><li>
<p>undefined characters in destination_encoding -&gt; hexadecimal CharRef such
as &amp;#xHH;</p>
</li></ul>
</dd></dl>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-comment"># UTF-16BE to UTF-8</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;UTF-16BE&quot;</span>, <span class="ruby-string">&quot;UTF-8&quot;</span>)

<span class="ruby-comment"># Usually, decorators such as newline conversion are inserted last.</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;UTF-16BE&quot;</span>, <span class="ruby-string">&quot;UTF-8&quot;</span>, :<span class="ruby-identifier">universal_newline</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convpath</span> <span class="ruby-comment">#=&gt; [[#&lt;Encoding:UTF-16BE&gt;, #&lt;Encoding:UTF-8&gt;],</span>
              <span class="ruby-comment">#    &quot;universal_newline&quot;]</span>

<span class="ruby-comment"># But, if the last encoding is ASCII incompatible,</span>
<span class="ruby-comment"># decorators are inserted before the last conversion.</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;UTF-8&quot;</span>, <span class="ruby-string">&quot;UTF-16BE&quot;</span>, :<span class="ruby-identifier">crlf_newline</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convpath</span> <span class="ruby-comment">#=&gt; [&quot;crlf_newline&quot;,</span>
              <span class="ruby-comment">#    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-16BE&gt;]]</span>

<span class="ruby-comment"># Conversion path can be specified directly.</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>([<span class="ruby-string">&quot;universal_newline&quot;</span>, [<span class="ruby-string">&quot;EUC-JP&quot;</span>, <span class="ruby-string">&quot;UTF-8&quot;</span>], [<span class="ruby-string">&quot;UTF-8&quot;</span>, <span class="ruby-string">&quot;UTF-16BE&quot;</span>]])
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convpath</span> <span class="ruby-comment">#=&gt; [&quot;universal_newline&quot;,</span>
              <span class="ruby-comment">#    [#&lt;Encoding:EUC-JP&gt;, #&lt;Encoding:UTF-8&gt;],</span>
              <span class="ruby-comment">#    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-16BE&gt;]]</span>
</pre>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3374
3375
3376
3377
3378
3379
3380
3381
3382
3383
3384
3385
3386
3387
3388
3389
3390
3391
3392
3393
3394
3395
3396
3397
3398
3399
3400
3401
3402
3403
3404
3405
3406
3407
3408
3409
3410
3411
3412
3413
3414
3415
3416</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c', line 3374</span>

static VALUE
econv_init(int argc, VALUE *argv, VALUE self)
{
    VALUE ecopts;
    volatile VALUE snamev, dnamev;
    const char *sname, *dname;
    rb_encoding *senc, *denc;
    rb_econv_t *ec;
    int ecflags;
    VALUE convpath;

    if (rb_check_typeddata(self, &amp;econv_data_type)) {
        rb_raise(rb_eTypeError, &quot;already initialized&quot;);
    }

    if (argc == 1 &amp;&amp; !NIL_P(convpath = rb_check_array_type(argv[0]))) {
        ec = rb_econv_init_by_convpath(self, convpath, &amp;sname, &amp;dname, &amp;senc, &amp;denc);
        ecflags = 0;
        ecopts = Qnil;
    }
    else {
        econv_args(argc, argv, &amp;snamev, &amp;dnamev, &amp;sname, &amp;dname, &amp;senc, &amp;denc, &amp;ecflags, &amp;ecopts);
        ec = rb_econv_open_opts(sname, dname, ecflags, ecopts);
    }

    if (!ec) {
        rb_exc_raise(rb_econv_open_exc(sname, dname, ecflags));
    }

    if (!DECORATOR_P(sname, dname)) {
        if (!senc)
            senc = make_dummy_encoding(sname);
        if (!denc)
            denc = make_dummy_encoding(dname);
    }

    ec-&gt;source_encoding = senc;
    ec-&gt;destination_encoding = denc;

    DATA_PTR(self) = ec;

    return self;
}</pre>
    </td>
  </tr>
</table>
</div>
  
</div>


  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="asciicompat_encoding-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt><sup>?</sup>) <strong>Encoding::Converter.asciicompat_encoding</strong>(string) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt><sup>?</sup>) <strong>Encoding::Converter.asciicompat_encoding</strong>(encoding) </span>
    
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns the corresponding ASCII compatible encoding.</p>

<p>Returns nil if the argument is an ASCII compatible encoding.</p>

<p>“corresponding ASCII compatible encoding” is a ASCII compatible encoding
which can represents exactly the same characters as the given ASCII
incompatible encoding. So, no conversion undefined error occurs when
converting between the two encodings.</p>

<pre class="ruby"><span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">asciicompat_encoding</span>(<span class="ruby-string">&quot;ISO-2022-JP&quot;</span>) <span class="ruby-comment">#=&gt; #&lt;Encoding:stateless-ISO-2022-JP&gt;</span>
<span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">asciicompat_encoding</span>(<span class="ruby-string">&quot;UTF-16BE&quot;</span>) <span class="ruby-comment">#=&gt; #&lt;Encoding:UTF-8&gt;</span>
<span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">asciicompat_encoding</span>(<span class="ruby-string">&quot;UTF-8&quot;</span>) <span class="ruby-comment">#=&gt; nil</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <p class="tag_title">Overloads:</p>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt><sup>?</sup>) <strong>Encoding::Converter.asciicompat_encoding</strong>(string) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt><sup>?</sup>) <strong>Encoding::Converter.asciicompat_encoding</strong>(encoding) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2979
2980
2981
2982
2983
2984
2985
2986
2987
2988
2989
2990
2991
2992
2993
2994
2995</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c', line 2979</span>

static VALUE
econv_s_asciicompat_encoding(VALUE klass, VALUE arg)
{
    const char *arg_name, *result_name;
    rb_encoding *arg_enc, *result_enc;

    enc_arg(&amp;arg, &amp;arg_name, &amp;arg_enc);

    result_name = rb_econv_asciicompat_encoding(arg_name);

    if (result_name == NULL)
        return Qnil;

    result_enc = make_encoding(result_name);

    return rb_enc_from_encoding(result_enc);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="search_convpath-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>Encoding::Converter.search_convpath</strong>(source_encoding, destination_encoding) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>Encoding::Converter.search_convpath</strong>(source_encoding, destination_encoding, opt) </span>
    
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns a conversion path.</p>

<pre class="ruby"><span class="ruby-identifier">p</span> <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">search_convpath</span>(<span class="ruby-string">&quot;ISO-8859-1&quot;</span>, <span class="ruby-string">&quot;EUC-JP&quot;</span>)
<span class="ruby-comment">#=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],</span>
<span class="ruby-comment">#    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;]]</span>

<span class="ruby-identifier">p</span> <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">search_convpath</span>(<span class="ruby-string">&quot;ISO-8859-1&quot;</span>, <span class="ruby-string">&quot;EUC-JP&quot;</span>, <span class="ruby-identifier">universal_newline</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>)
<span class="ruby-keyword">or</span>
<span class="ruby-identifier">p</span> <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">search_convpath</span>(<span class="ruby-string">&quot;ISO-8859-1&quot;</span>, <span class="ruby-string">&quot;EUC-JP&quot;</span>, <span class="ruby-identifier">newline</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">universal</span>)
<span class="ruby-comment">#=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],</span>
<span class="ruby-comment">#    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;],</span>
<span class="ruby-comment">#    &quot;universal_newline&quot;]</span>

<span class="ruby-identifier">p</span> <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">search_convpath</span>(<span class="ruby-string">&quot;ISO-8859-1&quot;</span>, <span class="ruby-string">&quot;UTF-32BE&quot;</span>, <span class="ruby-identifier">universal_newline</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>)
<span class="ruby-keyword">or</span>
<span class="ruby-identifier">p</span> <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">search_convpath</span>(<span class="ruby-string">&quot;ISO-8859-1&quot;</span>, <span class="ruby-string">&quot;UTF-32BE&quot;</span>, <span class="ruby-identifier">newline</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">universal</span>)
<span class="ruby-comment">#=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],</span>
<span class="ruby-comment">#    &quot;universal_newline&quot;,</span>
<span class="ruby-comment">#    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-32BE&gt;]]</span>
</pre>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3141
3142
3143
3144
3145
3146
3147
3148
3149
3150
3151
3152
3153
3154
3155
3156
3157
3158
3159
3160
3161
3162
3163</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c', line 3141</span>

static VALUE
econv_s_search_convpath(int argc, VALUE *argv, VALUE klass)
{
    volatile VALUE snamev, dnamev;
    const char *sname, *dname;
    rb_encoding *senc, *denc;
    int ecflags;
    VALUE ecopts;
    VALUE convpath;

    econv_args(argc, argv, &amp;snamev, &amp;dnamev, &amp;sname, &amp;dname, &amp;senc, &amp;denc, &amp;ecflags, &amp;ecopts);

    convpath = Qnil;
    transcode_search_path(sname, dname, search_convpath_i, &amp;convpath);

    if (NIL_P(convpath))
        rb_exc_raise(rb_econv_open_exc(sname, dname, ecflags));

    if (decorate_convpath(convpath, ecflags) == -1)
        rb_exc_raise(rb_econv_open_exc(sname, dname, ecflags));

    return convpath;
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="==-instance_method">
  
    - (<tt>Boolean</tt>) <strong>==</strong>(other) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3536
3537
3538
3539
3540
3541
3542
3543
3544
3545
3546
3547
3548
3549
3550
3551
3552
3553
3554
3555
3556
3557
3558
3559
3560
3561
3562
3563
3564
3565
3566
3567
3568
3569</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c', line 3536</span>

static VALUE
econv_equal(VALUE self, VALUE other)
{
    rb_econv_t *ec1 = check_econv(self);
    rb_econv_t *ec2;
    int i;

    if (!rb_typeddata_is_kind_of(other, &amp;econv_data_type)) {
	return Qnil;
    }
    ec2 = DATA_PTR(other);
    if (!ec2) return Qfalse;
    if (ec1-&gt;source_encoding_name != ec2-&gt;source_encoding_name &amp;&amp;
	strcmp(ec1-&gt;source_encoding_name, ec2-&gt;source_encoding_name))
	return Qfalse;
    if (ec1-&gt;destination_encoding_name != ec2-&gt;destination_encoding_name &amp;&amp;
	strcmp(ec1-&gt;destination_encoding_name, ec2-&gt;destination_encoding_name))
	return Qfalse;
    if (ec1-&gt;flags != ec2-&gt;flags) return Qfalse;
    if (ec1-&gt;replacement_enc != ec2-&gt;replacement_enc &amp;&amp;
	strcmp(ec1-&gt;replacement_enc, ec2-&gt;replacement_enc))
	return Qfalse;
    if (ec1-&gt;replacement_len != ec2-&gt;replacement_len) return Qfalse;
    if (ec1-&gt;replacement_str != ec2-&gt;replacement_str &amp;&amp;
	memcmp(ec1-&gt;replacement_str, ec2-&gt;replacement_str, ec2-&gt;replacement_len))
	return Qfalse;

    if (ec1-&gt;num_trans != ec2-&gt;num_trans) return Qfalse;
    for (i = 0; i &lt; ec1-&gt;num_trans; i++) {
        if (ec1-&gt;elems[i].tc-&gt;transcoder != ec2-&gt;elems[i].tc-&gt;transcoder)
	    return Qfalse;
    }
    return Qtrue;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="convert-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>convert</strong>(source_string) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Convert source_string and return destination_string.</p>

<p>source_string is assumed as a part of source. i.e.  :partial_input=&gt;true
is specified internally. finish method should be used last.</p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;utf-8&quot;</span>, <span class="ruby-string">&quot;euc-jp&quot;</span>)
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convert</span>(<span class="ruby-string">&quot;\u3042&quot;</span>).<span class="ruby-identifier">dump</span>     <span class="ruby-comment">#=&gt; &quot;\xA4\xA2&quot;</span>
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">finish</span>.<span class="ruby-identifier">dump</span>                <span class="ruby-comment">#=&gt; &quot;&quot;</span>

<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;euc-jp&quot;</span>, <span class="ruby-string">&quot;utf-8&quot;</span>)
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convert</span>(<span class="ruby-string">&quot;\xA4&quot;</span>).<span class="ruby-identifier">dump</span>       <span class="ruby-comment">#=&gt; &quot;&quot;</span>
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convert</span>(<span class="ruby-string">&quot;\xA2&quot;</span>).<span class="ruby-identifier">dump</span>       <span class="ruby-comment">#=&gt; &quot;\xE3\x81\x82&quot;</span>
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">finish</span>.<span class="ruby-identifier">dump</span>                <span class="ruby-comment">#=&gt; &quot;&quot;</span>

<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;utf-8&quot;</span>, <span class="ruby-string">&quot;iso-2022-jp&quot;</span>)
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convert</span>(<span class="ruby-string">&quot;\xE3&quot;</span>).<span class="ruby-identifier">dump</span>       <span class="ruby-comment">#=&gt; &quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)</span>
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convert</span>(<span class="ruby-string">&quot;\x81&quot;</span>).<span class="ruby-identifier">dump</span>       <span class="ruby-comment">#=&gt; &quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)</span>
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convert</span>(<span class="ruby-string">&quot;\x82&quot;</span>).<span class="ruby-identifier">dump</span>       <span class="ruby-comment">#=&gt; &quot;\e$B$\&quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)</span>
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">finish</span>.<span class="ruby-identifier">dump</span>                <span class="ruby-comment">#=&gt; &quot;\e(B&quot;.force_encoding(&quot;ISO-2022-JP&quot;)</span>
</pre>

<p>If a conversion error occur, Encoding::UndefinedConversionError or
Encoding::InvalidByteSequenceError is raised. Encoding::Converter#convert
doesn’t supply methods to recover or restart from these exceptions. When
you want to handle these conversion errors, use
Encoding::Converter#primitive_convert.</p>


  </div>
</div>
<div class="tags">
  
  


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3822
3823
3824
3825
3826
3827
3828
3829
3830
3831
3832
3833
3834
3835
3836
3837
3838
3839
3840
3841
3842
3843
3844
3845
3846
3847
3848
3849
3850
3851
3852
3853
3854
3855
3856
3857
3858
3859</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c', line 3822</span>

static VALUE
econv_convert(VALUE self, VALUE source_string)
{
    VALUE ret, dst;
    VALUE av[5];
    int ac;
    rb_econv_t *ec = check_econv(self);

    StringValue(source_string);

    dst = rb_str_new(NULL, 0);

    av[0] = rb_str_dup(source_string);
    av[1] = dst;
    av[2] = Qnil;
    av[3] = Qnil;
    av[4] = INT2NUM(ECONV_PARTIAL_INPUT);
    ac = 5;

    ret = econv_primitive_convert(ac, av, self);

    if (ret == sym_invalid_byte_sequence ||
        ret == sym_undefined_conversion ||
        ret == sym_incomplete_input) {
        VALUE exc = make_econv_exception(ec);
        rb_exc_raise(exc);
    }

    if (ret == sym_finished) {
        rb_raise(rb_eArgError, &quot;converter already finished&quot;);
    }

    if (ret != sym_source_buffer_empty) {
        rb_bug(&quot;unexpected result of econv_primitive_convert&quot;);
    }

    return dst;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="convpath-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>convpath</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns the conversion path of ec.</p>

<p>The result is an array of conversions.</p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;ISO-8859-1&quot;</span>, <span class="ruby-string">&quot;EUC-JP&quot;</span>, <span class="ruby-identifier">crlf_newline</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convpath</span>
<span class="ruby-comment">#=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],</span>
<span class="ruby-comment">#    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;],</span>
<span class="ruby-comment">#    &quot;crlf_newline&quot;]</span>
</pre>

<p>Each element of the array is a pair of encodings or a string. A pair means
an encoding conversion. A string means a decorator.</p>

<p>In the above example, [#&lt;Encoding:ISO-8859-1&gt;,
#&lt;Encoding:UTF-8&gt;] means a converter from ISO-8859-1 to UTF-8.
“crlf_newline” means newline converter from LF to CRLF.</p>


  </div>
</div>
<div class="tags">
  
  


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3512
3513
3514
3515
3516
3517
3518
3519
3520
3521
3522
3523
3524
3525
3526
3527
3528
3529
3530</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c', line 3512</span>

static VALUE
econv_convpath(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    VALUE result;
    int i;

    result = rb_ary_new();
    for (i = 0; i &lt; ec-&gt;num_trans; i++) {
        const rb_transcoder *tr = ec-&gt;elems[i].tc-&gt;transcoder;
        VALUE v;
        if (DECORATOR_P(tr-&gt;src_encoding, tr-&gt;dst_encoding))
            v = rb_str_new_cstr(tr-&gt;dst_encoding);
        else
            v = rb_assoc_new(make_encobj(tr-&gt;src_encoding), make_encobj(tr-&gt;dst_encoding));
        rb_ary_push(result, v);
    }
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="destination_encoding-instance_method">
  
    - (<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt>) <strong>destination_encoding</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns the destination encoding as an Encoding object.</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3481
3482
3483
3484
3485
3486
3487
3488</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c', line 3481</span>

static VALUE
econv_destination_encoding(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    if (!ec-&gt;destination_encoding)
        return Qnil;
    return rb_enc_from_encoding(ec-&gt;destination_encoding);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="finish-instance_method">
  
    - (<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>) <strong>finish</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Finishes the converter. It returns the last part of the converted string.</p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;utf-8&quot;</span>, <span class="ruby-string">&quot;iso-2022-jp&quot;</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convert</span>(<span class="ruby-string">&quot;\u3042&quot;</span>)     <span class="ruby-comment">#=&gt; &quot;\e$B$\&quot;&quot;</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">finish</span>                <span class="ruby-comment">#=&gt; &quot;\e(B&quot;</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3872
3873
3874
3875
3876
3877
3878
3879
3880
3881
3882
3883
3884
3885
3886
3887
3888
3889
3890
3891
3892
3893
3894
3895
3896
3897
3898
3899
3900
3901
3902
3903</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c', line 3872</span>

static VALUE
econv_finish(VALUE self)
{
    VALUE ret, dst;
    VALUE av[5];
    int ac;
    rb_econv_t *ec = check_econv(self);

    dst = rb_str_new(NULL, 0);

    av[0] = Qnil;
    av[1] = dst;
    av[2] = Qnil;
    av[3] = Qnil;
    av[4] = INT2NUM(0);
    ac = 5;

    ret = econv_primitive_convert(ac, av, self);

    if (ret == sym_invalid_byte_sequence ||
        ret == sym_undefined_conversion ||
        ret == sym_incomplete_input) {
        VALUE exc = make_econv_exception(ec);
        rb_exc_raise(exc);
    }

    if (ret != sym_finished) {
        rb_bug(&quot;unexpected result of econv_primitive_convert&quot;);
    }

    return dst;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="insert_output-instance_method">
  
    - (<tt>nil</tt>) <strong>insert_output</strong>(string) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Inserts string into the encoding converter. The string will be converted to
the destination encoding and output on later conversions.</p>

<p>If the destination encoding is stateful, string is converted according to
the state and the state is updated.</p>

<p>This method should be used only when a conversion error occurs.</p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;utf-8&quot;</span>, <span class="ruby-string">&quot;iso-8859-1&quot;</span>)
<span class="ruby-identifier">src</span> = <span class="ruby-string">&quot;HIRAGANA LETTER A is \u{3042}.&quot;</span>
<span class="ruby-identifier">dst</span> = <span class="ruby-string">&quot;&quot;</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>)    <span class="ruby-comment">#=&gt; :undefined_conversion</span>
<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;[#{dst.dump}, #{src.dump}]&quot;</span>   <span class="ruby-comment">#=&gt; [&quot;HIRAGANA LETTER A is &quot;, &quot;.&quot;]</span>
<span class="ruby-identifier">ec</span>.<span class="ruby-identifier">insert_output</span>(<span class="ruby-string">&quot;&lt;err&gt;&quot;</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>)    <span class="ruby-comment">#=&gt; :finished</span>
<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;[#{dst.dump}, #{src.dump}]&quot;</span>   <span class="ruby-comment">#=&gt; [&quot;HIRAGANA LETTER A is &lt;err&gt;.&quot;, &quot;&quot;]</span>

<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;utf-8&quot;</span>, <span class="ruby-string">&quot;iso-2022-jp&quot;</span>)
<span class="ruby-identifier">src</span> = <span class="ruby-string">&quot;\u{306F 3041 3068 2661 3002}&quot;</span> <span class="ruby-comment"># U+2661 is not representable in iso-2022-jp</span>
<span class="ruby-identifier">dst</span> = <span class="ruby-string">&quot;&quot;</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>)    <span class="ruby-comment">#=&gt; :undefined_conversion</span>
<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;[#{dst.dump}, #{src.dump}]&quot;</span>   <span class="ruby-comment">#=&gt; [&quot;\e$B$O$!$H&quot;.force_encoding(&quot;ISO-2022-JP&quot;), &quot;\xE3\x80\x82&quot;]</span>
<span class="ruby-identifier">ec</span>.<span class="ruby-identifier">insert_output</span> <span class="ruby-string">&quot;?&quot;</span>                <span class="ruby-comment"># state change required to output &quot;?&quot;.</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>)    <span class="ruby-comment">#=&gt; :finished</span>
<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;[#{dst.dump}, #{src.dump}]&quot;</span>   <span class="ruby-comment">#=&gt; [&quot;\e$B$O$!$H\e(B?\e$B!#\e(B&quot;.force_encoding(&quot;ISO-2022-JP&quot;), &quot;&quot;]</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4038
4039
4040
4041
4042
4043
4044
4045
4046
4047
4048
4049
4050
4051
4052
4053
4054
4055
4056
4057</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c', line 4038</span>

static VALUE
econv_insert_output(VALUE self, VALUE string)
{
    const char *insert_enc;

    int ret;

    rb_econv_t *ec = check_econv(self);

    StringValue(string);
    insert_enc = rb_econv_encoding_to_insert_output(ec);
    string = rb_str_encode(string, rb_enc_from_encoding(rb_enc_find(insert_enc)), 0, Qnil);

    ret = rb_econv_insert_output(ec, (const unsigned char *)RSTRING_PTR(string), RSTRING_LEN(string), insert_enc);
    if (ret == -1) {
	rb_raise(rb_eArgError, &quot;too big string&quot;);
    }

    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="inspect-instance_method">
  
    - (<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>) <strong>inspect</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns a printable version of <em>ec</em></p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;iso-8859-1&quot;</span>, <span class="ruby-string">&quot;utf-8&quot;</span>)
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">inspect</span>    <span class="ruby-comment">#=&gt; #&lt;Encoding::Converter: ISO-8859-1 to UTF-8&gt;</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3428
3429
3430
3431
3432
3433
3434
3435
3436
3437
3438
3439
3440
3441
3442
3443
3444
3445
3446</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c', line 3428</span>

static VALUE
econv_inspect(VALUE self)
{
    const char *cname = rb_obj_classname(self);
    rb_econv_t *ec;

    TypedData_Get_Struct(self, rb_econv_t, &amp;econv_data_type, ec);
    if (!ec)
        return rb_sprintf(&quot;#&lt;%s: uninitialized&gt;&quot;, cname);
    else {
        const char *sname = ec-&gt;source_encoding_name;
        const char *dname = ec-&gt;destination_encoding_name;
        VALUE str;
        str = rb_sprintf(&quot;#&lt;%s: &quot;, cname);
        econv_description(sname, dname, ec-&gt;flags, str);
        rb_str_cat2(str, &quot;&gt;&quot;);
        return str;
    }
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="last_error-instance_method">
  
    - (<tt><span class='object_link'><a href="../Exception.html" title="Exception (class)">Exception</a></span></tt><sup>?</sup>) <strong>last_error</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns an exception object for the last conversion. Returns nil if the
last conversion did not produce an error.</p>

<p>“error” means that Encoding::InvalidByteSequenceError and
Encoding::UndefinedConversionError for Encoding::Converter#convert and
:invalid_byte_sequence, :incomplete_input and :undefined_conversion for
Encoding::Converter#primitive_convert.</p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;utf-8&quot;</span>, <span class="ruby-string">&quot;iso-8859-1&quot;</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>=<span class="ruby-string">&quot;\xf1abcd&quot;</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>)       <span class="ruby-comment">#=&gt; :invalid_byte_sequence</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">last_error</span>      <span class="ruby-comment">#=&gt; #&lt;Encoding::InvalidByteSequenceError: &quot;\xF1&quot; followed by &quot;a&quot; on UTF-8&gt;</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">1</span>)             <span class="ruby-comment">#=&gt; :destination_buffer_full</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">last_error</span>      <span class="ruby-comment">#=&gt; nil</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../Exception.html" title="Exception (class)">Exception</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4132
4133
4134
4135
4136
4137
4138
4139
4140
4141
4142</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c', line 4132</span>

static VALUE
econv_last_error(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    VALUE exc;

    exc = make_econv_exception(ec);
    if (NIL_P(exc))
        return Qnil;
    return exc;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="primitive_convert-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>primitive_convert</strong>(source_buffer, destination_buffer) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>primitive_convert</strong>(source_buffer, destination_buffer, destination_byteoffset) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>primitive_convert</strong>(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>primitive_convert</strong>(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize, opt) </span>
    
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>possible opt elements:</p>

<pre class="ruby"><span class="ruby-identifier">hash</span> <span class="ruby-identifier">form</span><span class="ruby-operator">:</span>
  :<span class="ruby-identifier">partial_input</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>           <span class="ruby-comment"># source buffer may be part of larger source</span>
  :<span class="ruby-identifier">after_output</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>            <span class="ruby-comment"># stop conversion after output before input</span>
<span class="ruby-identifier">integer</span> <span class="ruby-identifier">form</span><span class="ruby-operator">:</span>
  <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span><span class="ruby-operator">::</span><span class="ruby-constant">PARTIAL_INPUT</span>
  <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span><span class="ruby-operator">::</span><span class="ruby-constant">AFTER_OUTPUT</span>
</pre>

<p>possible results:</p>

<pre class="code"><code class=""><span class='symbol'>:invalid_byte_sequence</span>
<span class='symbol'>:incomplete_input</span>
<span class='symbol'>:undefined_conversion</span>
<span class='symbol'>:after_output</span>
<span class='symbol'>:destination_buffer_full</span>
<span class='symbol'>:source_buffer_empty</span>
<span class='symbol'>:finished</span></code></pre>

<p>primitive_convert converts source_buffer into destination_buffer.</p>

<p>source_buffer should be a string or nil. nil means a empty string.</p>

<p>destination_buffer should be a string.</p>

<p>destination_byteoffset should be an integer or nil. nil means the end of
destination_buffer. If it is omitted, nil is assumed.</p>

<p>destination_bytesize should be an integer or nil. nil means unlimited. If
it is omitted, nil is assumed.</p>

<p>opt should be nil, a hash or an integer. nil means no flags. If it is
omitted, nil is assumed.</p>

<p>primitive_convert converts the content of source_buffer from beginning and
store the result into destination_buffer.</p>

<p>destination_byteoffset and destination_bytesize specify the region which
the converted result is stored. destination_byteoffset specifies the start
position in destination_buffer in bytes. If destination_byteoffset is nil,
destination_buffer.bytesize is used for appending the result.
destination_bytesize specifies maximum number of bytes. If
destination_bytesize is nil, destination size is unlimited. After
conversion, destination_buffer is resized to destination_byteoffset +
actually produced number of bytes. Also destination_buffer’s encoding is
set to destination_encoding.</p>

<p>primitive_convert drops the converted part of source_buffer. the dropped
part is converted in destination_buffer or buffered in Encoding::Converter
object.</p>

<p>primitive_convert stops conversion when one of following condition met.</p>
<ul><li>
<p>invalid byte sequence found in source buffer (:invalid_byte_sequence)</p>
</li><li>
<p>unexpected end of source buffer (:incomplete_input) this occur only when
:partial_input is not specified.</p>
</li><li>
<p>character not representable in output encoding (:undefined_conversion)</p>
</li><li>
<p>after some output is generated, before input is done (:after_output) this
occur only when :after_output is specified.</p>
</li><li>
<p>destination buffer is full (:destination_buffer_full) this occur only when
destination_bytesize is non-nil.</p>
</li><li>
<p>source buffer is empty (:source_buffer_empty) this occur only when
:partial_input is specified.</p>
</li><li>
<p>conversion is finished (:finished)</p>
</li></ul>

<p>example:</p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;UTF-8&quot;</span>, <span class="ruby-string">&quot;UTF-16BE&quot;</span>)
<span class="ruby-identifier">ret</span> = <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>=<span class="ruby-string">&quot;pi&quot;</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">100</span>)
<span class="ruby-identifier">p</span> [<span class="ruby-identifier">ret</span>, <span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>] <span class="ruby-comment">#=&gt; [:finished, &quot;&quot;, &quot;\x00p\x00i&quot;]</span>

<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;UTF-8&quot;</span>, <span class="ruby-string">&quot;UTF-16BE&quot;</span>)
<span class="ruby-identifier">ret</span> = <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>=<span class="ruby-string">&quot;pi&quot;</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">1</span>)
<span class="ruby-identifier">p</span> [<span class="ruby-identifier">ret</span>, <span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>] <span class="ruby-comment">#=&gt; [:destination_buffer_full, &quot;i&quot;, &quot;\x00&quot;]</span>
<span class="ruby-identifier">ret</span> = <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">1</span>)
<span class="ruby-identifier">p</span> [<span class="ruby-identifier">ret</span>, <span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>] <span class="ruby-comment">#=&gt; [:destination_buffer_full, &quot;&quot;, &quot;p&quot;]</span>
<span class="ruby-identifier">ret</span> = <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">1</span>)
<span class="ruby-identifier">p</span> [<span class="ruby-identifier">ret</span>, <span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>] <span class="ruby-comment">#=&gt; [:destination_buffer_full, &quot;&quot;, &quot;\x00&quot;]</span>
<span class="ruby-identifier">ret</span> = <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">1</span>)
<span class="ruby-identifier">p</span> [<span class="ruby-identifier">ret</span>, <span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>] <span class="ruby-comment">#=&gt; [:finished, &quot;&quot;, &quot;i&quot;]</span>
</pre>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3677
3678
3679
3680
3681
3682
3683
3684
3685
3686
3687
3688
3689
3690
3691
3692
3693
3694
3695
3696
3697
3698
3699
3700
3701
3702
3703
3704
3705
3706
3707
3708
3709
3710
3711
3712
3713
3714
3715
3716
3717
3718
3719
3720
3721
3722
3723
3724
3725
3726
3727
3728
3729
3730
3731
3732
3733
3734
3735
3736
3737
3738
3739
3740
3741
3742
3743
3744
3745
3746
3747
3748
3749
3750
3751
3752
3753
3754
3755
3756
3757
3758
3759
3760
3761
3762
3763
3764
3765
3766
3767
3768
3769
3770
3771
3772
3773
3774
3775
3776
3777
3778
3779
3780
3781
3782
3783
3784
3785
3786</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c', line 3677</span>

static VALUE
econv_primitive_convert(int argc, VALUE *argv, VALUE self)
{
    VALUE input, output, output_byteoffset_v, output_bytesize_v, opt, flags_v;
    rb_econv_t *ec = check_econv(self);
    rb_econv_result_t res;
    const unsigned char *ip, *is;
    unsigned char *op, *os;
    long output_byteoffset, output_bytesize;
    unsigned long output_byteend;
    int flags;

    argc = rb_scan_args(argc, argv, &quot;23:&quot;, &amp;input, &amp;output, &amp;output_byteoffset_v, &amp;output_bytesize_v, &amp;flags_v, &amp;opt);

    if (NIL_P(output_byteoffset_v))
        output_byteoffset = 0; /* dummy */
    else
        output_byteoffset = NUM2LONG(output_byteoffset_v);

    if (NIL_P(output_bytesize_v))
        output_bytesize = 0; /* dummy */
    else
        output_bytesize = NUM2LONG(output_bytesize_v);

    if (!NIL_P(flags_v)) {
	if (!NIL_P(opt)) {
	    rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 2..5)&quot;,
		argc + 1);
	}
	flags = NUM2INT(rb_to_int(flags_v));
    }
    else if (!NIL_P(opt)) {
        VALUE v;
        flags = 0;
        v = rb_hash_aref(opt, sym_partial_input);
        if (RTEST(v))
            flags |= ECONV_PARTIAL_INPUT;
        v = rb_hash_aref(opt, sym_after_output);
        if (RTEST(v))
            flags |= ECONV_AFTER_OUTPUT;
    }
    else {
        flags = 0;
    }

    StringValue(output);
    if (!NIL_P(input))
        StringValue(input);
    rb_str_modify(output);

    if (NIL_P(output_bytesize_v)) {
        output_bytesize = RSTRING_EMBED_LEN_MAX;
        if (!NIL_P(input) &amp;&amp; output_bytesize &lt; RSTRING_LEN(input))
            output_bytesize = RSTRING_LEN(input);
    }

  retry:

    if (NIL_P(output_byteoffset_v))
        output_byteoffset = RSTRING_LEN(output);

    if (output_byteoffset &lt; 0)
        rb_raise(rb_eArgError, &quot;negative output_byteoffset&quot;);

    if (RSTRING_LEN(output) &lt; output_byteoffset)
        rb_raise(rb_eArgError, &quot;output_byteoffset too big&quot;);

    if (output_bytesize &lt; 0)
        rb_raise(rb_eArgError, &quot;negative output_bytesize&quot;);

    output_byteend = (unsigned long)output_byteoffset +
                     (unsigned long)output_bytesize;

    if (output_byteend &lt; (unsigned long)output_byteoffset ||
        LONG_MAX &lt; output_byteend)
        rb_raise(rb_eArgError, &quot;output_byteoffset+output_bytesize too big&quot;);

    if (rb_str_capacity(output) &lt; output_byteend)
        rb_str_resize(output, output_byteend);

    if (NIL_P(input)) {
        ip = is = NULL;
    }
    else {
        ip = (const unsigned char *)RSTRING_PTR(input);
        is = ip + RSTRING_LEN(input);
    }

    op = (unsigned char *)RSTRING_PTR(output) + output_byteoffset;
    os = op + output_bytesize;

    res = rb_econv_convert(ec, &amp;ip, is, &amp;op, os, flags);
    rb_str_set_len(output, op-(unsigned char *)RSTRING_PTR(output));
    if (!NIL_P(input))
        rb_str_drop_bytes(input, ip - (unsigned char *)RSTRING_PTR(input));

    if (NIL_P(output_bytesize_v) &amp;&amp; res == econv_destination_buffer_full) {
        if (LONG_MAX / 2 &lt; output_bytesize)
            rb_raise(rb_eArgError, &quot;too long conversion result&quot;);
        output_bytesize *= 2;
        output_byteoffset_v = Qnil;
        goto retry;
    }

    if (ec-&gt;destination_encoding) {
        rb_enc_associate(output, ec-&gt;destination_encoding);
    }

    return econv_result_to_symbol(res);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="primitive_errinfo-instance_method">
  
    - (<tt><span class='object_link'><a href="../Array.html" title="Array (class)">Array</a></span></tt>) <strong>primitive_errinfo</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>primitive_errinfo returns important information regarding the last error as
a 5-element array:</p>

<pre class="code"><code class=""><span class='lbracket'>[</span><span class='id identifier rubyid_result'>result</span><span class='comma'>,</span> <span class='id identifier rubyid_enc1'>enc1</span><span class='comma'>,</span> <span class='id identifier rubyid_enc2'>enc2</span><span class='comma'>,</span> <span class='id identifier rubyid_error_bytes'>error_bytes</span><span class='comma'>,</span> <span class='id identifier rubyid_readagain_bytes'>readagain_bytes</span><span class='rbracket'>]</span></code></pre>

<p>result is the last result of primitive_convert.</p>

<p>Other elements are only meaningful when result is :invalid_byte_sequence,
:incomplete_input or :undefined_conversion.</p>

<p>enc1 and enc2 indicate a conversion step as a pair of strings. For example,
a converter from EUC-JP to ISO-8859-1 converts a string as follows: EUC-JP
-&gt; UTF-8 -&gt; ISO-8859-1. So [enc1, enc2] is either [“EUC-JP”, “UTF-8”]
or [“UTF-8”, “ISO-8859-1”].</p>

<p>error_bytes and readagain_bytes indicate the byte sequences which caused
the error. error_bytes is discarded portion. readagain_bytes is buffered
portion which is read again on next conversion.</p>

<p>Example:</p>

<pre class="ruby"><span class="ruby-comment"># \xff is invalid as EUC-JP.</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;EUC-JP&quot;</span>, <span class="ruby-string">&quot;Shift_JIS&quot;</span>)
<span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>=<span class="ruby-string">&quot;\xff&quot;</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">10</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_errinfo</span>
<span class="ruby-comment">#=&gt; [:invalid_byte_sequence, &quot;EUC-JP&quot;, &quot;UTF-8&quot;, &quot;\xFF&quot;, &quot;&quot;]</span>

<span class="ruby-comment"># HIRAGANA LETTER A (\xa4\xa2 in EUC-JP) is not representable in ISO-8859-1.</span>
<span class="ruby-comment"># Since this error is occur in UTF-8 to ISO-8859-1 conversion,</span>
<span class="ruby-comment"># error_bytes is HIRAGANA LETTER A in UTF-8 (\xE3\x81\x82).</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;EUC-JP&quot;</span>, <span class="ruby-string">&quot;ISO-8859-1&quot;</span>)
<span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>=<span class="ruby-string">&quot;\xa4\xa2&quot;</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">10</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_errinfo</span>
<span class="ruby-comment">#=&gt; [:undefined_conversion, &quot;UTF-8&quot;, &quot;ISO-8859-1&quot;, &quot;\xE3\x81\x82&quot;, &quot;&quot;]</span>

<span class="ruby-comment"># partial character is invalid</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;EUC-JP&quot;</span>, <span class="ruby-string">&quot;ISO-8859-1&quot;</span>)
<span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>=<span class="ruby-string">&quot;\xa4&quot;</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">10</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_errinfo</span>
<span class="ruby-comment">#=&gt; [:incomplete_input, &quot;EUC-JP&quot;, &quot;UTF-8&quot;, &quot;\xA4&quot;, &quot;&quot;]</span>

<span class="ruby-comment"># Encoding::Converter::PARTIAL_INPUT prevents invalid errors by</span>
<span class="ruby-comment"># partial characters.</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;EUC-JP&quot;</span>, <span class="ruby-string">&quot;ISO-8859-1&quot;</span>)
<span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>=<span class="ruby-string">&quot;\xa4&quot;</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">10</span>, <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span><span class="ruby-operator">::</span><span class="ruby-constant">PARTIAL_INPUT</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_errinfo</span>
<span class="ruby-comment">#=&gt; [:source_buffer_empty, nil, nil, nil, nil]</span>

<span class="ruby-comment"># \xd8\x00\x00@ is invalid as UTF-16BE because</span>
<span class="ruby-comment"># no low surrogate after high surrogate (\xd8\x00).</span>
<span class="ruby-comment"># It is detected by 3rd byte (\00) which is part of next character.</span>
<span class="ruby-comment"># So the high surrogate (\xd8\x00) is discarded and</span>
<span class="ruby-comment"># the 3rd byte is read again later.</span>
<span class="ruby-comment"># Since the byte is buffered in ec, it is dropped from src.</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;UTF-16BE&quot;</span>, <span class="ruby-string">&quot;UTF-8&quot;</span>)
<span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>=<span class="ruby-string">&quot;\xd8\x00\x00@&quot;</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">10</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_errinfo</span>
<span class="ruby-comment">#=&gt; [:invalid_byte_sequence, &quot;UTF-16BE&quot;, &quot;UTF-8&quot;, &quot;\xD8\x00&quot;, &quot;\x00&quot;]</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">src</span>
<span class="ruby-comment">#=&gt; &quot;@&quot;</span>

<span class="ruby-comment"># Similar to UTF-16BE, \x00\xd8@\x00 is invalid as UTF-16LE.</span>
<span class="ruby-comment"># The problem is detected by 4th byte.</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;UTF-16LE&quot;</span>, <span class="ruby-string">&quot;UTF-8&quot;</span>)
<span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>=<span class="ruby-string">&quot;\x00\xd8@\x00&quot;</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">10</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_errinfo</span>
<span class="ruby-comment">#=&gt; [:invalid_byte_sequence, &quot;UTF-16LE&quot;, &quot;UTF-8&quot;, &quot;\x00\xD8&quot;, &quot;@\x00&quot;]</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">src</span>
<span class="ruby-comment">#=&gt; &quot;&quot;</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3980
3981
3982
3983
3984
3985
3986
3987
3988
3989
3990
3991
3992
3993
3994
3995
3996
3997
3998
3999
4000
4001
4002
4003
4004</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c', line 3980</span>

static VALUE
econv_primitive_errinfo(VALUE self)
{
    rb_econv_t *ec = check_econv(self);

    VALUE ary;

    ary = rb_ary_new2(5);

    rb_ary_store(ary, 0, econv_result_to_symbol(ec-&gt;last_error.result));
    rb_ary_store(ary, 4, Qnil);

    if (ec-&gt;last_error.source_encoding)
        rb_ary_store(ary, 1, rb_str_new2(ec-&gt;last_error.source_encoding));

    if (ec-&gt;last_error.destination_encoding)
        rb_ary_store(ary, 2, rb_str_new2(ec-&gt;last_error.destination_encoding));

    if (ec-&gt;last_error.error_bytes_start) {
        rb_ary_store(ary, 3, rb_str_new((const char *)ec-&gt;last_error.error_bytes_start, ec-&gt;last_error.error_bytes_len));
        rb_ary_store(ary, 4, rb_str_new((const char *)ec-&gt;last_error.error_bytes_start + ec-&gt;last_error.error_bytes_len, ec-&gt;last_error.readagain_len));
    }

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="putback-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>putback</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>call-seq</p>

<pre class="code"><code class="">ec.putback                    -&gt; string
ec.putback(max_numbytes)      -&gt; string</code></pre>

<p>Put back the bytes which will be converted.</p>

<p>The bytes are caused by invalid_byte_sequence error. When
invalid_byte_sequence error, some bytes are discarded and some bytes are
buffered to be converted later. The latter bytes can be put back. It can be
observed by Encoding::InvalidByteSequenceError#readagain_bytes and
Encoding::Converter#primitive_errinfo.</p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;utf-16le&quot;</span>, <span class="ruby-string">&quot;iso-8859-1&quot;</span>)
<span class="ruby-identifier">src</span> = <span class="ruby-string">&quot;\x00\xd8\x61\x00&quot;</span>
<span class="ruby-identifier">dst</span> = <span class="ruby-string">&quot;&quot;</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>)   <span class="ruby-comment">#=&gt; :invalid_byte_sequence</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_errinfo</span>     <span class="ruby-comment">#=&gt; [:invalid_byte_sequence, &quot;UTF-16LE&quot;, &quot;UTF-8&quot;, &quot;\x00\xD8&quot;, &quot;a\x00&quot;]</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">putback</span>               <span class="ruby-comment">#=&gt; &quot;a\x00&quot;</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">putback</span>               <span class="ruby-comment">#=&gt; &quot;&quot;          # no more bytes to put back</span>
</pre>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4083
4084
4085
4086
4087
4088
4089
4090
4091
4092
4093
4094
4095
4096
4097
4098
4099
4100
4101
4102
4103
4104
4105
4106
4107
4108
4109
4110</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c', line 4083</span>

static VALUE
econv_putback(int argc, VALUE *argv, VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    int n;
    int putbackable;
    VALUE str, max;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;max);

    if (NIL_P(max))
        n = rb_econv_putbackable(ec);
    else {
        n = NUM2INT(max);
        putbackable = rb_econv_putbackable(ec);
        if (putbackable &lt; n)
            n = putbackable;
    }

    str = rb_str_new(NULL, n);
    rb_econv_putback(ec, (unsigned char *)RSTRING_PTR(str), n);

    if (ec-&gt;source_encoding) {
        rb_enc_associate(str, ec-&gt;source_encoding);
    }

    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="replacement-instance_method">
  
    - (<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>) <strong>replacement</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns the replacement string.</p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;euc-jp&quot;</span>, <span class="ruby-string">&quot;us-ascii&quot;</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">replacement</span>    <span class="ruby-comment">#=&gt; &quot;?&quot;</span>

<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;euc-jp&quot;</span>, <span class="ruby-string">&quot;utf-8&quot;</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">replacement</span>    <span class="ruby-comment">#=&gt; &quot;\uFFFD&quot;</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4156
4157
4158
4159
4160
4161
4162
4163
4164
4165
4166
4167
4168
4169
4170</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c', line 4156</span>

static VALUE
econv_get_replacement(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    int ret;
    rb_encoding *enc;

    ret = make_replacement(ec);
    if (ret == -1) {
        rb_raise(rb_eUndefinedConversionError, &quot;replacement character setup failed&quot;);
    }

    enc = rb_enc_find(ec-&gt;replacement_enc);
    return rb_enc_str_new((const char *)ec-&gt;replacement_str, (long)ec-&gt;replacement_len, enc);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="replacement=-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>replacement=</strong>(string) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Sets the replacement string.</p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;utf-8&quot;</span>, <span class="ruby-string">&quot;us-ascii&quot;</span>, :<span class="ruby-keyword">undef</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">replace</span>)
<span class="ruby-identifier">ec</span>.<span class="ruby-identifier">replacement</span> = <span class="ruby-string">&quot;&lt;undef&gt;&quot;</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convert</span>(<span class="ruby-string">&quot;a \u3042 b&quot;</span>)      <span class="ruby-comment">#=&gt; &quot;a &lt;undef&gt; b&quot;</span>
</pre>


  </div>
</div>
<div class="tags">
  
  


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


4182
4183
4184
4185
4186
4187
4188
4189
4190
4191
4192
4193
4194
4195
4196
4197
4198
4199
4200
4201
4202
4203
4204</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c', line 4182</span>

static VALUE
econv_set_replacement(VALUE self, VALUE arg)
{
    rb_econv_t *ec = check_econv(self);
    VALUE string = arg;
    int ret;
    rb_encoding *enc;

    StringValue(string);
    enc = rb_enc_get(string);

    ret = rb_econv_set_replacement(ec,
            (const unsigned char *)RSTRING_PTR(string),
            RSTRING_LEN(string),
            rb_enc_name(enc));

    if (ret == -1) {
        /* xxx: rb_eInvalidByteSequenceError? */
        rb_raise(rb_eUndefinedConversionError, &quot;replacement character setup failed&quot;);
    }

    return arg;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="source_encoding-instance_method">
  
    - (<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt>) <strong>source_encoding</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns the source encoding as an Encoding object.</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3466
3467
3468
3469
3470
3471
3472
3473</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c', line 3466</span>

static VALUE
econv_source_encoding(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    if (!ec-&gt;source_encoding)
        return Qnil;
    return rb_enc_from_encoding(ec-&gt;source_encoding);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>

    <div id="footer">
  Generated on Wed Nov 19 10:16:46 2014 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.7.4 (ruby-1.9.3).
</div>

  </body>
</html>