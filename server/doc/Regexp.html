<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>
  Class: Regexp
  
    &mdash; Documentation by YARD 0.8.7.4
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '';
  framesUrl = "frames.html#!Regexp.html";
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index (R)</a> &raquo;
    
    
    <span class="title">Regexp</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><h1>Class: Regexp
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName"><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></span>
      
        <ul class="fullTree">
          <li><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></li>
          
            <li class="next">Regexp</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">re.c<span class="defines">,<br />
  re.c</span>
</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    
<p>A <code>Regexp</code> holds a regular expression, used to match a pattern
against strings. Regexps are created using the <code>/.../</code> and
<code>%r{...}</code> literals, and by the <code>Regexp::new</code>
constructor.</p>

<p>:include: doc/re.rdoc</p>


  </div>
</div>
<div class="tags">
  

</div>
  <h2>Constant Summary</h2>
  
    <dl class="constants">
      
        <dt id="IGNORECASE-constant" class="">IGNORECASE =
          <div class="docstring">
  <div class="discussion">
    
<p>see Regexp.options and Regexp.new</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ONIG_OPTION_IGNORECASE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="EXTENDED-constant" class="">EXTENDED =
          <div class="docstring">
  <div class="discussion">
    
<p>see Regexp.options and Regexp.new</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ONIG_OPTION_EXTEND</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="MULTILINE-constant" class="">MULTILINE =
          <div class="docstring">
  <div class="discussion">
    
<p>see Regexp.options and Regexp.new</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ONIG_OPTION_MULTILINE</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="FIXEDENCODING-constant" class="">FIXEDENCODING =
          <div class="docstring">
  <div class="discussion">
    
<p>see Regexp.options and Regexp.new</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ARG_ENCODING_FIXED</span><span class='rparen'>)</span></pre></dd>
      
        <dt id="NOENCODING-constant" class="">NOENCODING =
          <div class="docstring">
  <div class="discussion">
    
<p>see Regexp.options and Regexp.new</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>INT2FIX</span><span class='lparen'>(</span><span class='const'>ARG_ENCODING_NONE</span><span class='rparen'>)</span></pre></dd>
      
    </dl>
  







  
    <h2>
      Class Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#compile-class_method" title="new (class method)">+ (Object) <strong>new</strong>(args, ...) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Calls allocate to create a new object of class’s class, then invokes that
object’s initialize method, passing it args.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#escape-class_method" title="escape (class method)">+ (Object) <strong>escape</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Escapes any characters that would have special meaning in a regular
expression.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#last_match-class_method" title="last_match (class method)">+ (Object) <strong>last_match</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>The first form returns the MatchData object generated by the last
successful pattern match.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#quote-class_method" title="quote (class method)">+ (Object) <strong>quote</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Escapes any characters that would have special meaning in a regular
expression.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#try_convert-class_method" title="try_convert (class method)">+ (nil) <strong>try_convert</strong>(obj) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Try to convert obj into a Regexp, using to_regexp method.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#union-class_method" title="union (class method)">+ (Object) <strong>union</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Return a Regexp object that is the union of the given patterns, i.e., will
match any of its parts.</p>
</div></span>
  
</li>

      
    </ul>
  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%3D-instance_method" title="#== (instance method)">- (Object) <strong>==</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Equality—Two regexps are equal if their patterns are identical, they have
the same character set code, and their casefold? values are the same.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%3D%3D-instance_method" title="#=== (instance method)">- (Boolean) <strong>===</strong>(str) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Case Equality—Synonym for Regexp#=~ used in case statements.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%7E-instance_method" title="#=~ (instance method)">- (Integer<sup>?</sup>) <strong>=~</strong>(str) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Match—Matches rxp against str.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#casefold%3F-instance_method" title="#casefold? (instance method)">- (Boolean) <strong>casefold?</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns the value of the case-insensitive flag.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#encoding-instance_method" title="#encoding (instance method)">- (Encoding) <strong>encoding</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns the Encoding object that represents the encoding of obj.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eql%3F-instance_method" title="#eql? (instance method)">- (Boolean) <strong>eql?</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Equality—Two regexps are equal if their patterns are identical, they have
the same character set code, and their casefold? values are the same.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fixed_encoding%3F-instance_method" title="#fixed_encoding? (instance method)">- (Boolean) <strong>fixed_encoding?</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns false if rxp is applicable to a string with any ASCII compatible
encoding.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hash-instance_method" title="#hash (instance method)">- (Fixnum) <strong>hash</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Produce a hash based on the text and options of this regular expression.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize-instance_method" title="#initialize (instance method)">- (Object) <strong>initialize</strong> </a>
    

    
  </span>
  
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Constructs a new regular expression from pattern, which can be either a
String or a Regexp (in which case that regexp’s options are propagated, and
new options may not be specified (a change as of Ruby 1.8). If options is a
Fixnum, it should be one or more of the constants Regexp::EXTENDED,
Regexp::IGNORECASE, and Regexp::MULTILINE, or-ed together. Otherwise, if
options is not nil, the regexp will be case insensitive. When the lang
parameter is `n’ or `N’ sets the regexp no encoding.</p>

<pre class="ruby"><span class="ruby-identifier">r1</span> = <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'^a-z+:\s+\w+'</span>)           <span class="ruby-comment">#=&gt; /^a-z+:\s+\w+/    r2 = Regexp.new('cat', true)               #=&gt; /cat/i    r3 = Regexp.new('dog', Regexp::EXTENDED)   #=&gt; /dog/x    r4 = Regexp.new(r2)                        #=&gt; /cat/i.</span>
</pre>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize_copy-instance_method" title="#initialize_copy (instance method)">- (Object) <strong>initialize_copy</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>:nodoc:.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#inspect-instance_method" title="#inspect (instance method)">- (String) <strong>inspect</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Produce a nicely formatted string-version of <em>rxp</em>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#match-instance_method" title="#match (instance method)">- (Object) <strong>match</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns a MatchData object describing the match, or nil if there was no
match.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#named_captures-instance_method" title="#named_captures (instance method)">- (Hash) <strong>named_captures</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns a hash representing information about named captures of rxp.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#names-instance_method" title="#names (instance method)">- (Array) <strong>names</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns a list of names of captures as an array of strings.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#options-instance_method" title="#options (instance method)">- (Fixnum) <strong>options</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns the set of bits corresponding to the options used when creating
this Regexp (see Regexp::new for details. Note that additional bits may be
set in the returned options: these are used internally by the regular
expression code. These extra bits are ignored if the options are passed to
Regexp::new.</p>

<pre class="ruby"><span class="ruby-constant">Regexp</span><span class="ruby-operator">::</span><span class="ruby-constant">IGNORECASE</span>                  <span class="ruby-comment">#=&gt; 1    Regexp::EXTENDED                    #=&gt; 2    Regexp::MULTILINE                   #=&gt; 4</span>
<span class="ruby-regexp">/cat/</span>.<span class="ruby-identifier">options</span>                       <span class="ruby-comment">#=&gt; 0    /cat/ix.options                     #=&gt; 3    Regexp.new('cat', true).options     #=&gt; 1    /\xa1\xa2/e.options                 #=&gt; 16</span>
<span class="ruby-identifier">r</span> = <span class="ruby-regexp">/cat/</span><span class="ruby-identifier">x</span>    <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">r</span>.<span class="ruby-identifier">source</span>, <span class="ruby-identifier">r</span>.<span class="ruby-identifier">options</span>)     <span class="ruby-comment">#=&gt; /cat/ix.</span>
</pre>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#source-instance_method" title="#source (instance method)">- (String) <strong>source</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns the original string of the pattern.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_s-instance_method" title="#to_s (instance method)">- (String) <strong>to_s</strong> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns a string containing the regular expression and its options (using
the (?opts:source) notation. This string can be fed back in to Regexp::new
to a regular expression with the same semantics as the original. (However,
Regexp#== may not return true when comparing the two, as the source of the
regular expression itself may differ, as the example shows). 
Regexp#inspect produces a generally more readable version of rxp.</p>

<pre class="ruby"><span class="ruby-identifier">r1</span> = <span class="ruby-regexp">/ab+c/</span><span class="ruby-identifier">x</span>           <span class="ruby-comment">#=&gt; /ab+c/ix     s1 = r1.to_s            #=&gt; &quot;(?ix-m:ab+c)&quot;     r2 = Regexp.new(s1)     #=&gt; /(?ix-m:ab+c)/     r1 == r2                #=&gt; false     r1.source               #=&gt; &quot;ab+c&quot;     r2.source               #=&gt; &quot;(?ix-m:ab+c)&quot;.</span>
</pre>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%7E-instance_method" title="#~ (instance method)">- (Integer<sup>?</sup>) <strong>~</strong>(rxp) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Match—Matches rxp against the contents of $_.</p>
</div></span>
  
</li>

      
    </ul>
  

<div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <h3 class="signature first" id="initialize-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>new</strong>(string, [options [, lang]]) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>new</strong>(regexp) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>compile</strong>(string, [options [, lang]]) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>compile</strong>(regexp) </span>
    
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Constructs a new regular expression from <em>pattern</em>, which can be
either a <code>String</code> or a <code>Regexp</code> (in which case that
regexp’s options are propagated, and new options may not be specified (a
change as of Ruby 1.8). If <em>options</em> is a <code>Fixnum</code>, it
should be one or more of the constants <code>Regexp::EXTENDED</code>,
<code>Regexp::IGNORECASE</code>, and <code>Regexp::MULTILINE</code>,
<em>or</em>-ed together. Otherwise, if <em>options</em> is not
<code>nil</code>, the regexp will be case insensitive. When the
<em>lang</em> parameter is `n’ or `N’ sets the regexp no encoding.</p>

<pre class="ruby"><span class="ruby-identifier">r1</span> = <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'^a-z+:\s+\w+'</span>)           <span class="ruby-comment">#=&gt; /^a-z+:\s+\w+/</span>
<span class="ruby-identifier">r2</span> = <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'cat'</span>, <span class="ruby-keyword">true</span>)               <span class="ruby-comment">#=&gt; /cat/i</span>
<span class="ruby-identifier">r3</span> = <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'dog'</span>, <span class="ruby-constant">Regexp</span><span class="ruby-operator">::</span><span class="ruby-constant">EXTENDED</span>)   <span class="ruby-comment">#=&gt; /dog/x</span>
<span class="ruby-identifier">r4</span> = <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">r2</span>)                        <span class="ruby-comment">#=&gt; /cat/i</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <p class="tag_title">Overloads:</p>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>new</strong>(string, [options [, lang]]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>new</strong>(regexp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>compile</strong>(string, [options [, lang]]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>compile</strong>(regexp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  

</div>
      </li>
    
  </ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2896
2897
2898
2899
2900
2901
2902
2903
2904
2905
2906
2907
2908
2909
2910
2911
2912
2913
2914
2915
2916
2917
2918
2919
2920
2921
2922
2923
2924
2925
2926
2927
2928
2929
2930
2931
2932
2933
2934
2935
2936
2937
2938
2939
2940
2941
2942
2943
2944
2945
2946
2947
2948
2949
2950</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 2896</span>

static VALUE
rb_reg_initialize_m(int argc, VALUE *argv, VALUE self)
{
    onig_errmsg_buffer err = &quot;&quot;;
    int flags = 0;
    VALUE str;
    rb_encoding *enc;
    const char *ptr;
    long len;

    if (argc == 0 || argc &gt; 3) {
	rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 1..3)&quot;, argc);
    }
    if (TYPE(argv[0]) == T_REGEXP) {
	VALUE re = argv[0];

	if (argc &gt; 1) {
	    rb_warn(&quot;flags ignored&quot;);
	}
	rb_reg_check(re);
	flags = rb_reg_options(re);
	ptr = RREGEXP_SRC_PTR(re);
	len = RREGEXP_SRC_LEN(re);
	enc = rb_enc_get(re);
	if (rb_reg_initialize(self, ptr, len, enc, flags, err, NULL, 0)) {
	    str = rb_enc_str_new(ptr, len, enc);
	    rb_reg_raise_str(str, flags, err);
	}
    }
    else {
	if (argc &gt;= 2) {
	    if (FIXNUM_P(argv[1])) flags = FIX2INT(argv[1]);
	    else if (RTEST(argv[1])) flags = ONIG_OPTION_IGNORECASE;
	}
	enc = 0;
	if (argc == 3 &amp;&amp; !NIL_P(argv[2])) {
	    char *kcode = StringValuePtr(argv[2]);
	    if (kcode[0] == 'n' || kcode[0] == 'N') {
		enc = rb_ascii8bit_encoding();
		flags |= ARG_ENCODING_NONE;
	    }
	    else {
		rb_warn(&quot;encoding option is ignored - %s&quot;, kcode);
	    }
	}
	str = argv[0];
	ptr = StringValuePtr(str);
	if (enc
	    ? rb_reg_initialize(self, ptr, RSTRING_LEN(str), enc, flags, err, NULL, 0)
	    : rb_reg_initialize_str(self, str, flags, err, NULL, 0)) {
	    rb_reg_raise_str(str, flags, err);
	}
    }
    return self;
}</pre>
    </td>
  </tr>
</table>
</div>
  
</div>


  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="compile-class_method">
  
    + (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>new</strong>(args, ...) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Calls <code>allocate</code> to create a new object of <em>class</em>’s
class, then invokes that object’s <code>initialize</code> method, passing
it <em>args</em>. This is the method that ends up getting called whenever
an object is constructed using .new.</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1638
1639
1640
1641
1642
1643
1644
1645
1646
1647</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'object.c', line 1638</span>

VALUE
rb_class_new_instance(int argc, VALUE *argv, VALUE klass)
{
    VALUE obj;

    obj = rb_obj_alloc(klass);
    rb_obj_call_init(obj, argc, argv);

    return obj;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="escape-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>escape</strong>(str) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>quote</strong>(str) </span>
    
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Escapes any characters that would have special meaning in a regular
expression. Returns a new escaped string, or self if no characters are
escaped.  For any string,
<code>Regexp.new(Regexp.escape(<em>str</em>))=~<em>str</em></code> will be
true.</p>

<pre class="ruby"><span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">escape</span>(<span class="ruby-string">'\*?{}.'</span>)   <span class="ruby-comment">#=&gt; \\\*\?\{\}\.</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <p class="tag_title">Overloads:</p>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>escape</strong>(str) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>quote</strong>(str) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3064
3065
3066
3067
3068</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 3064</span>

static VALUE
rb_reg_s_quote(VALUE c, VALUE str)
{
    return rb_reg_quote(reg_operand(str, TRUE));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="last_match-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt>) <strong>last_match</strong> </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>last_match</strong>(n) </span>
    
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>The first form returns the <code>MatchData</code> object generated by the
last successful pattern match. Equivalent to reading the global variable
<code>$~</code>. The second form returns the <em>n</em>th field in this
<code>MatchData</code> object. <em>n</em> can be a string or symbol to
reference a named capture.</p>

<p>Note that the <code>last_match</code> is local to the thread and method
scope of the method that did the pattern match.</p>

<pre class="ruby"><span class="ruby-regexp">/c(.)t/</span> <span class="ruby-operator">=~</span> <span class="ruby-string">'cat'</span>        <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">last_match</span>       <span class="ruby-comment">#=&gt; #&lt;MatchData &quot;cat&quot; 1:&quot;a&quot;&gt;</span>
<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">last_match</span>(<span class="ruby-value">0</span>)    <span class="ruby-comment">#=&gt; &quot;cat&quot;</span>
<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">last_match</span>(<span class="ruby-value">1</span>)    <span class="ruby-comment">#=&gt; &quot;a&quot;</span>
<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">last_match</span>(<span class="ruby-value">2</span>)    <span class="ruby-comment">#=&gt; nil</span>

<span class="ruby-regexp">/(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/</span> <span class="ruby-operator">=~</span> <span class="ruby-string">&quot;var = val&quot;</span>
<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">last_match</span>       <span class="ruby-comment">#=&gt; #&lt;MatchData &quot;var = val&quot; lhs:&quot;var&quot; rhs:&quot;val&quot;&gt;</span>
<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">last_match</span>(:<span class="ruby-identifier">lhs</span>) <span class="ruby-comment">#=&gt; &quot;var&quot;</span>
<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">last_match</span>(:<span class="ruby-identifier">rhs</span>) <span class="ruby-comment">#=&gt; &quot;val&quot;</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <p class="tag_title">Overloads:</p>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt>) <strong>last_match</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>last_match</strong>(n) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3468
3469
3470
3471
3472
3473
3474
3475
3476
3477
3478
3479
3480
3481</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 3468</span>

static VALUE
rb_reg_s_last_match(int argc, VALUE *argv)
{
    VALUE nth;

    if (argc &gt; 0 &amp;&amp; rb_scan_args(argc, argv, &quot;01&quot;, &amp;nth) == 1) {
        VALUE match = rb_backref_get();
        int n;
        if (NIL_P(match)) return Qnil;
        n = match_backref_number(match, nth);
	return rb_reg_nth_match(n, match);
    }
    return match_getter();
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="quote-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>escape</strong>(str) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>quote</strong>(str) </span>
    
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Escapes any characters that would have special meaning in a regular
expression. Returns a new escaped string, or self if no characters are
escaped.  For any string,
<code>Regexp.new(Regexp.escape(<em>str</em>))=~<em>str</em></code> will be
true.</p>

<pre class="ruby"><span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">escape</span>(<span class="ruby-string">'\*?{}.'</span>)   <span class="ruby-comment">#=&gt; \\\*\?\{\}\.</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <p class="tag_title">Overloads:</p>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>escape</strong>(str) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>quote</strong>(str) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3064
3065
3066
3067
3068</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 3064</span>

static VALUE
rb_reg_s_quote(VALUE c, VALUE str)
{
    return rb_reg_quote(reg_operand(str, TRUE));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="try_convert-class_method">
  
    + (<tt>nil</tt>) <strong>try_convert</strong>(obj) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Try to convert <em>obj</em> into a Regexp, using to_regexp method. Returns
converted regexp or nil if <em>obj</em> cannot be converted for any reason.</p>

<pre class="ruby"><span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">try_convert</span>(<span class="ruby-regexp">/re/</span>)         <span class="ruby-comment">#=&gt; /re/</span>
<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">try_convert</span>(<span class="ruby-string">&quot;re&quot;</span>)         <span class="ruby-comment">#=&gt; nil</span>

<span class="ruby-identifier">o</span> = <span class="ruby-constant">Object</span>.<span class="ruby-identifier">new</span>
<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">try_convert</span>(<span class="ruby-identifier">o</span>)            <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">to_regexp</span>() <span class="ruby-operator">/</span><span class="ruby-identifier">foo</span><span class="ruby-operator">/</span> <span class="ruby-keyword">end</span>
<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">try_convert</span>(<span class="ruby-identifier">o</span>)            <span class="ruby-comment">#=&gt; /foo/</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3105
3106
3107
3108
3109</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 3105</span>

static VALUE
rb_reg_s_try_convert(VALUE dummy, VALUE re)
{
    return rb_check_regexp_type(re);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="union-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>union</strong>(pat1, pat2, ...) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>union</strong>(pats_ary) </span>
    
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Return a <code>Regexp</code> object that is the union of the given
<em>pattern</em>s, i.e., will match any of its parts. The <em>pattern</em>s
can be Regexp objects, in which case their options will be preserved, or
Strings. If no patterns are given, returns <code>/(?!)/</code>. The
behavior is unspecified if any given <em>pattern</em> contains capture.</p>

<pre class="ruby"><span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">union</span>                         <span class="ruby-comment">#=&gt; /(?!)/</span>
<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">union</span>(<span class="ruby-string">&quot;penzance&quot;</span>)             <span class="ruby-comment">#=&gt; /penzance/</span>
<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">union</span>(<span class="ruby-string">&quot;a+b*c&quot;</span>)                <span class="ruby-comment">#=&gt; /a\+b\*c/</span>
<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">union</span>(<span class="ruby-string">&quot;skiing&quot;</span>, <span class="ruby-string">&quot;sledding&quot;</span>)   <span class="ruby-comment">#=&gt; /skiing|sledding/</span>
<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">union</span>([<span class="ruby-string">&quot;skiing&quot;</span>, <span class="ruby-string">&quot;sledding&quot;</span>]) <span class="ruby-comment">#=&gt; /skiing|sledding/</span>
<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">union</span>(<span class="ruby-regexp">/dogs/</span>, <span class="ruby-regexp">/cats/</span>)        <span class="ruby-comment">#=&gt; /(?-mix:dogs)|(?i-mx:cats)/</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <p class="tag_title">Overloads:</p>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>union</strong>(pat1, pat2, ...) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>union</strong>(pats_ary) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3243
3244
3245
3246
3247
3248
3249
3250
3251
3252</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 3243</span>

static VALUE
rb_reg_s_union_m(VALUE self, VALUE args)
{
    VALUE v;
    if (RARRAY_LEN(args) == 1 &amp;&amp;
        !NIL_P(v = rb_check_array_type(rb_ary_entry(args, 0)))) {
        return rb_reg_s_union(self, v);
    }
    return rb_reg_s_union(self, args);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="==-instance_method">
  
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>==</strong>(other_rxp) </span>
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>eql?</strong>(other_rxp) </span>
    
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Equality—Two regexps are equal if their patterns are identical, they have
the same character set code, and their <code>casefold?</code> values are
the same.</p>

<pre class="ruby"><span class="ruby-regexp">/abc/</span>  <span class="ruby-operator">==</span> <span class="ruby-regexp">/abc/</span>   <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-regexp">/abc/</span>  <span class="ruby-operator">==</span> <span class="ruby-regexp">/abc/</span>   <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-regexp">/abc/</span>  <span class="ruby-operator">==</span> <span class="ruby-regexp">/abc/</span>   <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-regexp">/abc/</span> <span class="ruby-operator">==</span> <span class="ruby-regexp">/abc/</span>   <span class="ruby-comment">#=&gt; false</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <p class="tag_title">Overloads:</p>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>==</strong>(other_rxp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>eql?</strong>(other_rxp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2586
2587
2588
2589
2590
2591
2592
2593
2594
2595
2596
2597
2598
2599
2600</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 2586</span>

static VALUE
rb_reg_equal(VALUE re1, VALUE re2)
{
    if (re1 == re2) return Qtrue;
    if (TYPE(re2) != T_REGEXP) return Qfalse;
    rb_reg_check(re1); rb_reg_check(re2);
    if (FL_TEST(re1, KCODE_FIXED) != FL_TEST(re2, KCODE_FIXED)) return Qfalse;
    if (RREGEXP(re1)-&gt;ptr-&gt;options != RREGEXP(re2)-&gt;ptr-&gt;options) return Qfalse;
    if (RREGEXP_SRC_LEN(re1) != RREGEXP_SRC_LEN(re2)) return Qfalse;
    if (ENCODING_GET(re1) != ENCODING_GET(re2)) return Qfalse;
    if (memcmp(RREGEXP_SRC_PTR(re1), RREGEXP_SRC_PTR(re2), RREGEXP_SRC_LEN(re1)) == 0) {
	return Qtrue;
    }
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="===-instance_method">
  
    - (<tt>Boolean</tt>) <strong>===</strong>(str) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Case Equality—Synonym for <code>Regexp#=~</code> used in case statements.</p>

<pre class="code"><code class=""><span class='id identifier rubyid_a'>a</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>HELLO</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>case</span> <span class='id identifier rubyid_a'>a</span>
<span class='kw'>when</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^[a-z]*$</span><span class='regexp_end'>/</span></span><span class='semicolon'>;</span> <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Lower case\n</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>when</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^[A-Z]*$</span><span class='regexp_end'>/</span></span><span class='semicolon'>;</span> <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Upper case\n</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span><span class='semicolon'>;</span>            <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Mixed case\n</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span></code></pre>

<p><em>produces:</em></p>

<pre class="code"><code class="">Upper case</code></pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2763
2764
2765
2766
2767
2768
2769
2770
2771
2772
2773
2774
2775
2776
2777
2778</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 2763</span>

VALUE
rb_reg_eqq(VALUE re, VALUE str)
{
    long start;

    str = reg_operand(str, FALSE);
    if (NIL_P(str)) {
	rb_backref_set(Qnil);
	return Qfalse;
    }
    start = rb_reg_search(re, str, 0, 0);
    if (start &lt; 0) {
	return Qfalse;
    }
    return Qtrue;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="=~-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>=~</strong>(str) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Match—Matches <em>rxp</em> against <em>str</em>.</p>

<pre class="ruby"><span class="ruby-regexp">/at/</span> <span class="ruby-operator">=~</span> <span class="ruby-string">&quot;input data&quot;</span>   <span class="ruby-comment">#=&gt; 7</span>
<span class="ruby-regexp">/ax/</span> <span class="ruby-operator">=~</span> <span class="ruby-string">&quot;input data&quot;</span>   <span class="ruby-comment">#=&gt; nil</span>
</pre>

<p>If <code>=~</code> is used with a regexp literal with named captures,
captured strings (or nil) is assigned to local variables named by the
capture names.</p>

<pre class="ruby"><span class="ruby-regexp">/(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/</span> <span class="ruby-operator">=~</span> <span class="ruby-string">&quot;  x = y  &quot;</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">lhs</span>    <span class="ruby-comment">#=&gt; &quot;x&quot;</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">rhs</span>    <span class="ruby-comment">#=&gt; &quot;y&quot;</span>
</pre>

<p>If it is not matched, nil is assigned for the variables.</p>

<pre class="ruby"><span class="ruby-regexp">/(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/</span> <span class="ruby-operator">=~</span> <span class="ruby-string">&quot;  x = &quot;</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">lhs</span>    <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">rhs</span>    <span class="ruby-comment">#=&gt; nil</span>
</pre>

<p>This assignment is implemented in the Ruby parser. The parser detects
‘regexp-literal =~ expression’ for the assignment. The regexp must be a
literal without interpolation and placed at left hand side.</p>

<p>The assignment does not occur if the regexp is not a literal.</p>

<pre class="code"><code class=""><span class='id identifier rubyid_re'>re</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)</span><span class='regexp_end'>/</span></span>
<span class='id identifier rubyid_re'>re</span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  x = y  </span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_lhs'>lhs</span>    <span class='comment'># undefined local variable
</span><span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_rhs'>rhs</span>    <span class='comment'># undefined local variable</span></code></pre>

<p>A regexp interpolation, <code>#{}</code>, also disables the assignment.</p>

<pre class="code"><code class=""><span class='id identifier rubyid_rhs_pat'>rhs_pat</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;rhs&gt;\w+)</span><span class='regexp_end'>/</span></span>
<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;lhs&gt;\w+)\s*=\s*</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_rhs_pat'>rhs_pat</span><span class='rbrace'>}</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>x = y</span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_lhs'>lhs</span>    <span class='comment'># undefined local variable</span></code></pre>

<p>The assignment does not occur if the regexp is placed at the right hand
side.</p>

<pre class="code"><code class=""><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  x = y  </span><span class='tstring_end'>&quot;</span></span> <span class='op'>=~</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)</span><span class='regexp_end'>/</span></span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_lhs'>lhs</span><span class='comma'>,</span> <span class='id identifier rubyid_rhs'>rhs</span> <span class='comment'># undefined local variable</span></code></pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2736
2737
2738
2739
2740
2741
2742
2743</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 2736</span>

VALUE
rb_reg_match(VALUE re, VALUE str)
{
    long pos = reg_match_pos(re, &amp;str, 0);
    if (pos &lt; 0) return Qnil;
    pos = rb_str_sublen(str, pos);
    return LONG2FIX(pos);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="casefold?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>casefold?</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns the value of the case-insensitive flag.</p>

<pre class="ruby"><span class="ruby-regexp">/a/</span>.<span class="ruby-identifier">casefold?</span>           <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-regexp">/a/</span>.<span class="ruby-identifier">casefold?</span>          <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-regexp">/(?i:a)/</span>.<span class="ruby-identifier">casefold?</span>      <span class="ruby-comment">#=&gt; false</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


645
646
647
648
649
650
651</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 645</span>

static VALUE
rb_reg_casefold_p(VALUE re)
{
    rb_reg_check(re);
    if (RREGEXP(re)-&gt;ptr-&gt;options &amp; ONIG_OPTION_IGNORECASE) return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="encoding-instance_method">
  
    - (<tt><span class='object_link'><a href="Encoding.html" title="Encoding (class)">Encoding</a></span></tt>) <strong>encoding</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns the Encoding object that represents the encoding of obj.</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Encoding.html" title="Encoding (class)">Encoding</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


830
831
832
833
834
835
836
837
838</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'encoding.c', line 830</span>

VALUE
rb_obj_encoding(VALUE obj)
{
    rb_encoding *enc = rb_enc_get(obj);
    if (!enc) {
	rb_raise(rb_eTypeError, &quot;unknown encoding&quot;);
    }
    return rb_enc_from_encoding(enc);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="eql?-instance_method">
  
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>==</strong>(other_rxp) </span>
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>eql?</strong>(other_rxp) </span>
    
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Equality—Two regexps are equal if their patterns are identical, they have
the same character set code, and their <code>casefold?</code> values are
the same.</p>

<pre class="ruby"><span class="ruby-regexp">/abc/</span>  <span class="ruby-operator">==</span> <span class="ruby-regexp">/abc/</span>   <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-regexp">/abc/</span>  <span class="ruby-operator">==</span> <span class="ruby-regexp">/abc/</span>   <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-regexp">/abc/</span>  <span class="ruby-operator">==</span> <span class="ruby-regexp">/abc/</span>   <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-regexp">/abc/</span> <span class="ruby-operator">==</span> <span class="ruby-regexp">/abc/</span>   <span class="ruby-comment">#=&gt; false</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <p class="tag_title">Overloads:</p>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>==</strong>(other_rxp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>eql?</strong>(other_rxp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2586
2587
2588
2589
2590
2591
2592
2593
2594
2595
2596
2597
2598
2599
2600</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 2586</span>

static VALUE
rb_reg_equal(VALUE re1, VALUE re2)
{
    if (re1 == re2) return Qtrue;
    if (TYPE(re2) != T_REGEXP) return Qfalse;
    rb_reg_check(re1); rb_reg_check(re2);
    if (FL_TEST(re1, KCODE_FIXED) != FL_TEST(re2, KCODE_FIXED)) return Qfalse;
    if (RREGEXP(re1)-&gt;ptr-&gt;options != RREGEXP(re2)-&gt;ptr-&gt;options) return Qfalse;
    if (RREGEXP_SRC_LEN(re1) != RREGEXP_SRC_LEN(re2)) return Qfalse;
    if (ENCODING_GET(re1) != ENCODING_GET(re2)) return Qfalse;
    if (memcmp(RREGEXP_SRC_PTR(re1), RREGEXP_SRC_PTR(re2), RREGEXP_SRC_LEN(re1)) == 0) {
	return Qtrue;
    }
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fixed_encoding?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>fixed_encoding?</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns false if rxp is applicable to a string with any ASCII compatible
encoding. Returns true otherwise.</p>

<pre class="ruby"><span class="ruby-identifier">r</span> = <span class="ruby-regexp">/a/</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">fixed_encoding?</span>                               <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-identifier">r</span> <span class="ruby-operator">=~</span> <span class="ruby-string">&quot;\u{6666} a&quot;</span>                               <span class="ruby-comment">#=&gt; 2</span>
<span class="ruby-identifier">r</span> <span class="ruby-operator">=~</span> <span class="ruby-string">&quot;\xa1\xa2 a&quot;</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-string">&quot;euc-jp&quot;</span>)      <span class="ruby-comment">#=&gt; 2</span>
<span class="ruby-identifier">r</span> <span class="ruby-operator">=~</span> <span class="ruby-string">&quot;abc&quot;</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-string">&quot;euc-jp&quot;</span>)             <span class="ruby-comment">#=&gt; 0</span>

<span class="ruby-identifier">r</span> = <span class="ruby-regexp">/a/</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">fixed_encoding?</span>                               <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">encoding</span>                                      <span class="ruby-comment">#=&gt; #&lt;Encoding:UTF-8&gt;</span>
<span class="ruby-identifier">r</span> <span class="ruby-operator">=~</span> <span class="ruby-string">&quot;\u{6666} a&quot;</span>                               <span class="ruby-comment">#=&gt; 2</span>
<span class="ruby-identifier">r</span> <span class="ruby-operator">=~</span> <span class="ruby-string">&quot;\xa1\xa2&quot;</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-string">&quot;euc-jp&quot;</span>)        <span class="ruby-comment">#=&gt; ArgumentError</span>
<span class="ruby-identifier">r</span> <span class="ruby-operator">=~</span> <span class="ruby-string">&quot;abc&quot;</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-string">&quot;euc-jp&quot;</span>)             <span class="ruby-comment">#=&gt; 0</span>

<span class="ruby-identifier">r</span> = <span class="ruby-regexp">/\u{6666}/</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">fixed_encoding?</span>                               <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">encoding</span>                                      <span class="ruby-comment">#=&gt; #&lt;Encoding:UTF-8&gt;</span>
<span class="ruby-identifier">r</span> <span class="ruby-operator">=~</span> <span class="ruby-string">&quot;\u{6666} a&quot;</span>                               <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-identifier">r</span> <span class="ruby-operator">=~</span> <span class="ruby-string">&quot;\xa1\xa2&quot;</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-string">&quot;euc-jp&quot;</span>)        <span class="ruby-comment">#=&gt; ArgumentError</span>
<span class="ruby-identifier">r</span> <span class="ruby-operator">=~</span> <span class="ruby-string">&quot;abc&quot;</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-string">&quot;euc-jp&quot;</span>)             <span class="ruby-comment">#=&gt; nil</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


1211
1212
1213
1214
1215
1216
1217
1218</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 1211</span>

static VALUE
rb_reg_fixed_encoding_p(VALUE re)
{
    if (FL_TEST(re, KCODE_FIXED))
        return Qtrue;
    else
        return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hash-instance_method">
  
    - (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>) <strong>hash</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Produce a hash based on the text and options of this regular expression.</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2552
2553
2554
2555
2556
2557</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 2552</span>

static VALUE
rb_reg_hash(VALUE re)
{
    st_index_t hashval = reg_hash(re);
    return LONG2FIX(hashval);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="initialize_copy-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>initialize_copy</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>:nodoc:</p>


  </div>
</div>
<div class="tags">
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


3255
3256
3257
3258
3259
3260
3261
3262
3263
3264
3265
3266
3267
3268
3269
3270
3271
3272
3273
3274
3275
3276</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 3255</span>

static VALUE
rb_reg_init_copy(VALUE copy, VALUE re)
{
    onig_errmsg_buffer err = &quot;&quot;;
    const char *s;
    long len;

    if (copy == re) return copy;
    rb_check_frozen(copy);
    /* need better argument type check */
    if (!rb_obj_is_instance_of(re, rb_obj_class(copy))) {
	rb_raise(rb_eTypeError, &quot;wrong argument type&quot;);
    }
    rb_reg_check(re);
    s = RREGEXP_SRC_PTR(re);
    len = RREGEXP_SRC_LEN(re);
    if (rb_reg_initialize(copy, s, len, rb_enc_get(re), rb_reg_options(re),
		err, NULL, 0) != 0) {
	rb_reg_raise(s, len, err, re);
    }
    return copy;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="inspect-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>inspect</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Produce a nicely formatted string-version of <em>rxp</em>. Perhaps
surprisingly, <code>#inspect</code> actually produces the more natural
version of the string than <code>#to_s</code>.</p>

<pre class="ruby"><span class="ruby-regexp">/ab+c/</span><span class="ruby-identifier">x</span>.<span class="ruby-identifier">inspect</span>        <span class="ruby-comment">#=&gt; &quot;/ab+c/ix&quot;</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


474
475
476
477
478
479
480
481</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 474</span>

static VALUE
rb_reg_inspect(VALUE re)
{
    if (!RREGEXP(re)-&gt;ptr || !RREGEXP_SRC(re) || !RREGEXP_SRC_PTR(re)) {
        return rb_any_to_s(re);
    }
    return rb_reg_desc(RREGEXP_SRC_PTR(re), RREGEXP_SRC_LEN(re), re);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="match-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt><sup>?</sup>) <strong>match</strong>(str) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt><sup>?</sup>) <strong>match</strong>(str, pos) </span>
    
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns a <code>MatchData</code> object describing the match, or
<code>nil</code> if there was no match. This is equivalent to retrieving
the value of the special variable <code>$~</code> following a normal match.
If the second parameter is present, it specifies the position in the string
to begin the search.</p>

<pre class="ruby"><span class="ruby-regexp">/(.)(.)(.)/</span>.<span class="ruby-identifier">match</span>(<span class="ruby-string">&quot;abc&quot;</span>)[<span class="ruby-value">2</span>]   <span class="ruby-comment">#=&gt; &quot;b&quot;</span>
<span class="ruby-regexp">/(.)(.)/</span>.<span class="ruby-identifier">match</span>(<span class="ruby-string">&quot;abc&quot;</span>, <span class="ruby-value">1</span>)[<span class="ruby-value">2</span>]   <span class="ruby-comment">#=&gt; &quot;c&quot;</span>
</pre>

<p>If a block is given, invoke the block with MatchData if match succeed, so
that you can write</p>

<pre class="ruby"><span class="ruby-identifier">pat</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">str</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-operator">...</span>}
</pre>

<p>instead of</p>

<pre class="code"><code class="">if m = pat.match(str)
  ...
end</code></pre>

<p>The return value is a value from block execution in this case.</p>


  </div>
</div>
<div class="tags">
  
  <p class="tag_title">Overloads:</p>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt><sup>?</sup>) <strong>match</strong>(str) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt><sup>?</sup>) <strong>match</strong>(str, pos) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2840
2841
2842
2843
2844
2845
2846
2847
2848
2849
2850
2851
2852
2853
2854
2855
2856
2857
2858
2859
2860
2861
2862
2863
2864</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 2840</span>

static VALUE
rb_reg_match_m(int argc, VALUE *argv, VALUE re)
{
    VALUE result, str, initpos;
    long pos;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;str, &amp;initpos) == 2) {
	pos = NUM2LONG(initpos);
    }
    else {
	pos = 0;
    }

    pos = reg_match_pos(re, &amp;str, pos);
    if (pos &lt; 0) {
	rb_backref_set(Qnil);
	return Qnil;
    }
    result = rb_backref_get();
    rb_match_busy(result);
    if (!NIL_P(result) &amp;&amp; rb_block_given_p()) {
	return rb_yield(result);
    }
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="named_captures-instance_method">
  
    - (<tt><span class='object_link'><a href="Hash.html" title="Hash (class)">Hash</a></span></tt>) <strong>named_captures</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns a hash representing information about named captures of
<em>rxp</em>.</p>

<p>A key of the hash is a name of the named captures. A value of the hash is
an array which is list of indexes of corresponding named captures.</p>

<pre class="ruby"><span class="ruby-regexp">/(?&lt;foo&gt;.)(?&lt;bar&gt;.)/</span>.<span class="ruby-identifier">named_captures</span>
<span class="ruby-comment">#=&gt; {&quot;foo&quot;=&gt;[1], &quot;bar&quot;=&gt;[2]}</span>

<span class="ruby-regexp">/(?&lt;foo&gt;.)(?&lt;foo&gt;.)/</span>.<span class="ruby-identifier">named_captures</span>
<span class="ruby-comment">#=&gt; {&quot;foo&quot;=&gt;[1, 2]}</span>
</pre>

<p>If there are no named captures, an empty hash is returned.</p>

<pre class="ruby"><span class="ruby-regexp">/(.)(.)/</span>.<span class="ruby-identifier">named_captures</span>
<span class="ruby-comment">#=&gt; {}</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Hash.html" title="Hash (class)">Hash</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


756
757
758
759
760
761
762
763</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 756</span>

static VALUE
rb_reg_named_captures(VALUE re)
{
    VALUE hash = rb_hash_new();
    rb_reg_check(re);
    onig_foreach_name(RREGEXP(re)-&gt;ptr, reg_named_captures_iter, (void*)hash);
    return hash;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="names-instance_method">
  
    - (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>names</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns a list of names of captures as an array of strings.</p>

<pre class="ruby"><span class="ruby-regexp">/(?&lt;foo&gt;.)(?&lt;bar&gt;.)(?&lt;baz&gt;.)/</span>.<span class="ruby-identifier">names</span>
<span class="ruby-comment">#=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>

<span class="ruby-regexp">/(?&lt;foo&gt;.)(?&lt;foo&gt;.)/</span>.<span class="ruby-identifier">names</span>
<span class="ruby-comment">#=&gt; [&quot;foo&quot;]</span>

<span class="ruby-regexp">/(.)(.)/</span>.<span class="ruby-identifier">names</span>
<span class="ruby-comment">#=&gt; []</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


709
710
711
712
713
714
715
716</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 709</span>

static VALUE
rb_reg_names(VALUE re)
{
    VALUE ary = rb_ary_new();
    rb_reg_check(re);
    onig_foreach_name(RREGEXP(re)-&gt;ptr, reg_names_iter, (void*)ary);
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="options-instance_method">
  
    - (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>) <strong>options</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns the set of bits corresponding to the options used when creating
this Regexp (see <code>Regexp::new</code> for details. Note that additional
bits may be set in the returned options: these are used internally by the
regular expression code. These extra bits are ignored if the options are
passed to <code>Regexp::new</code>.</p>

<pre class="ruby"><span class="ruby-constant">Regexp</span><span class="ruby-operator">::</span><span class="ruby-constant">IGNORECASE</span>                  <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-constant">Regexp</span><span class="ruby-operator">::</span><span class="ruby-constant">EXTENDED</span>                    <span class="ruby-comment">#=&gt; 2</span>
<span class="ruby-constant">Regexp</span><span class="ruby-operator">::</span><span class="ruby-constant">MULTILINE</span>                   <span class="ruby-comment">#=&gt; 4</span>

<span class="ruby-regexp">/cat/</span>.<span class="ruby-identifier">options</span>                       <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-regexp">/cat/</span><span class="ruby-identifier">x</span>.<span class="ruby-identifier">options</span>                     <span class="ruby-comment">#=&gt; 3</span>
<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'cat'</span>, <span class="ruby-keyword">true</span>).<span class="ruby-identifier">options</span>     <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-regexp">/\xa1\xa2/</span>.<span class="ruby-identifier">options</span>                 <span class="ruby-comment">#=&gt; 16</span>

<span class="ruby-identifier">r</span> = <span class="ruby-regexp">/cat/</span><span class="ruby-identifier">x</span>
<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">r</span>.<span class="ruby-identifier">source</span>, <span class="ruby-identifier">r</span>.<span class="ruby-identifier">options</span>)     <span class="ruby-comment">#=&gt; /cat/ix</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


677
678
679
680
681
682</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 677</span>

static VALUE
rb_reg_options_m(VALUE re)
{
    int options = rb_reg_options(re);
    return INT2NUM(options);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="source-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>source</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns the original string of the pattern.</p>

<pre class="ruby"><span class="ruby-regexp">/ab+c/</span><span class="ruby-identifier">x</span>.<span class="ruby-identifier">source</span> <span class="ruby-comment">#=&gt; &quot;ab+c&quot;</span>
</pre>

<p>Note that escape sequences are retained as is.</p>

<pre class="ruby"><span class="ruby-regexp">/\x20\+/</span>.<span class="ruby-identifier">source</span>  <span class="ruby-comment">#=&gt; &quot;\\x20\\+&quot;</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


451
452
453
454
455
456
457
458
459
460</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 451</span>

static VALUE
rb_reg_source(VALUE re)
{
    VALUE str;

    rb_reg_check(re);
    str = rb_enc_str_new(RREGEXP_SRC_PTR(re),RREGEXP_SRC_LEN(re), rb_enc_get(re));
    if (OBJ_TAINTED(re)) OBJ_TAINT(str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="to_s-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>to_s</strong> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns a string containing the regular expression and its options (using
the <code>(?opts:source)</code> notation. This string can be fed back in to
<code>Regexp::new</code> to a regular expression with the same semantics as
the original. (However, <code>Regexp#==</code> may not return true when
comparing the two, as the source of the regular expression itself may
differ, as the example shows).  <code>Regexp#inspect</code> produces a
generally more readable version of <em>rxp</em>.</p>

<pre class="ruby"><span class="ruby-identifier">r1</span> = <span class="ruby-regexp">/ab+c/</span><span class="ruby-identifier">x</span>           <span class="ruby-comment">#=&gt; /ab+c/ix</span>
<span class="ruby-identifier">s1</span> = <span class="ruby-identifier">r1</span>.<span class="ruby-identifier">to_s</span>            <span class="ruby-comment">#=&gt; &quot;(?ix-m:ab+c)&quot;</span>
<span class="ruby-identifier">r2</span> = <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">s1</span>)     <span class="ruby-comment">#=&gt; /(?ix-m:ab+c)/</span>
<span class="ruby-identifier">r1</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">r2</span>                <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-identifier">r1</span>.<span class="ruby-identifier">source</span>               <span class="ruby-comment">#=&gt; &quot;ab+c&quot;</span>
<span class="ruby-identifier">r2</span>.<span class="ruby-identifier">source</span>               <span class="ruby-comment">#=&gt; &quot;(?ix-m:ab+c)&quot;</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 504</span>

static VALUE
rb_reg_to_s(VALUE re)
{
    int options, opt;
    const int embeddable = ONIG_OPTION_MULTILINE|ONIG_OPTION_IGNORECASE|ONIG_OPTION_EXTEND;
    long len;
    const UChar* ptr;
    VALUE str = rb_str_buf_new2(&quot;(?&quot;);
    char optbuf[5];
    rb_encoding *enc = rb_enc_get(re);

    rb_reg_check(re);

    rb_enc_copy(str, re);
    options = RREGEXP(re)-&gt;ptr-&gt;options;
    ptr = (UChar*)RREGEXP_SRC_PTR(re);
    len = RREGEXP_SRC_LEN(re);
  again:
    if (len &gt;= 4 &amp;&amp; ptr[0] == '(' &amp;&amp; ptr[1] == '?') {
	int err = 1;
	ptr += 2;
	if ((len -= 2) &gt; 0) {
	    do {
                opt = char_to_option((int )*ptr);
                if (opt != 0) {
                    options |= opt;
                }
                else {
                    break;
                }
		++ptr;
	    } while (--len &gt; 0);
	}
	if (len &gt; 1 &amp;&amp; *ptr == '-') {
	    ++ptr;
	    --len;
	    do {
                opt = char_to_option((int )*ptr);
                if (opt != 0) {
                    options &amp;= ~opt;
                }
                else {
                    break;
                }
		++ptr;
	    } while (--len &gt; 0);
	}
	if (*ptr == ')') {
	    --len;
	    ++ptr;
	    goto again;
	}
	if (*ptr == ':' &amp;&amp; ptr[len-1] == ')') {
	    Regexp *rp;

	    ++ptr;
	    len -= 2;
            err = onig_new(&amp;rp, ptr, ptr + len, ONIG_OPTION_DEFAULT,
			   enc, OnigDefaultSyntax, NULL);
	    onig_free(rp);
	}
	if (err) {
	    options = RREGEXP(re)-&gt;ptr-&gt;options;
	    ptr = (UChar*)RREGEXP_SRC_PTR(re);
	    len = RREGEXP_SRC_LEN(re);
	}
    }

    if (*option_to_str(optbuf, options)) rb_str_buf_cat2(str, optbuf);

    if ((options &amp; embeddable) != embeddable) {
	optbuf[0] = '-';
	option_to_str(optbuf + 1, ~options);
	rb_str_buf_cat2(str, optbuf);
    }

    rb_str_buf_cat2(str, &quot;:&quot;);
    rb_reg_expr_str(str, (char*)ptr, len, enc, NULL);
    rb_str_buf_cat2(str, &quot;)&quot;);
    rb_enc_copy(str, re);

    OBJ_INFECT(str, re);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="~-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>~</strong>(rxp) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Match—Matches <em>rxp</em> against the contents of <code>$_</code>.
Equivalent to <code><em>rxp</em> =~ $_</code>.</p>

<pre class="ruby"><span class="ruby-identifier">$_</span> = <span class="ruby-string">&quot;input data&quot;</span>
<span class="ruby-operator">~</span> <span class="ruby-regexp">/at/</span>   <span class="ruby-comment">#=&gt; 7</span>
</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


2792
2793
2794
2795
2796
2797
2798
2799
2800
2801
2802
2803
2804
2805
2806
2807
2808
2809</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c', line 2792</span>

VALUE
rb_reg_match2(VALUE re)
{
    long start;
    VALUE line = rb_lastline_get();

    if (TYPE(line) != T_STRING) {
	rb_backref_set(Qnil);
	return Qnil;
    }

    start = rb_reg_search(re, line, 0, 0);
    if (start &lt; 0) {
	return Qnil;
    }
    start = rb_str_sublen(line, start);
    return LONG2FIX(start);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>

    <div id="footer">
  Generated on Wed Nov 19 10:17:00 2014 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.7.4 (ruby-1.9.3).
</div>

  </body>
</html>